Processing APK: be_vrt_buck.json
Parsing through functions (non-recursive)...

APK functions: {'<java.lang.System: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>'}, '<java.lang.StringBuilder: java.lang.String toString()>': {'code': '  toString  None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>'}, '<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>': {'code': '  append  None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>'}, '<java.lang.StringBuilder: void <init>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>'}, '<androidx.loader.app.LoaderManagerImpl: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>': {'code': '  dump  {\n            writer.print(prefix);\n            writer.print("mId=");\n            writer.print(this.mId);\n            writer.print(" mArgs=");\n            writer.println(this.mArgs);\n            writer.print(prefix);\n            writer.print("mLoader=");\n            writer.println(this.mLoader);\n            this.mLoader.dump(prefix + "  ", fd, writer, args);\n            if (this.mObserver != null) {\n                writer.print(prefix);\n                writer.print("mCallbacks=");\n                writer.println(this.mObserver);\n                this.mObserver.dump(prefix + "  ", writer);\n            }\n            writer.print(prefix);\n            writer.print("mData=");\n            writer.println(getLoader().dataToString(getValue()));\n            writer.print(prefix);\n            writer.print("mStarted=");\n            writer.println(hasActiveObservers());\n        }', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>'}, '<java.lang.Integer: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>'}, '<java.lang.System: int identityHashCode(java.lang.Object)>': {'code': '  identityHashCode  None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>'}, '<java.lang.Integer: java.lang.String toHexString(int)>': {'code': '  toHexString  None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>'}, '<androidx.loader.app.LoaderManager: androidx.loader.app.LoaderManager getInstance(androidx.lifecycle.LifecycleOwner)>': {'code': '  getInstance  {\n        return new LoaderManagerImpl(owner, owner.getViewModelStore());\n    }', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>'}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>': {'code': 'void  dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])  {\n        super.dump(prefix, fd, writer, args);\n        writer.print(prefix);\n        writer.print("Local FragmentActivity ");\n        writer.print(Integer.toHexString(System.identityHashCode(this)));\n        writer.println(" State:");\n        String innerPrefix = prefix + "  ";\n        writer.print(innerPrefix);\n        writer.print("mCreated=");\n        writer.print(this.mCreated);\n        writer.print(" mResumed=");\n        writer.print(this.mResumed);\n        writer.print(" mStopped=");\n        writer.print(this.mStopped);\n        if (getApplication() != null) {\n            LoaderManager.getInstance(this).dump(innerPrefix, fd, writer, args);\n        }\n        this.mFragments.getSupportFragmentManager().dump(prefix, fd, writer, args);\n    }', 'children': ['<java.lang.System: void <clinit>()>', '<java.lang.StringBuilder: java.lang.String toString()>', '<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>', '<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>', '<java.lang.StringBuilder: void <init>()>', '<androidx.loader.app.LoaderManagerImpl: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>', '<java.lang.Integer: void <clinit>()>', '<java.lang.System: int identityHashCode(java.lang.Object)>', '<java.lang.Integer: java.lang.String toHexString(int)>', '<androidx.loader.app.LoaderManager: androidx.loader.app.LoaderManager getInstance(androidx.lifecycle.LifecycleOwner)>']}, '<androidx.core.content.ContextCompat: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onActivityResult(int,int,android.content.Intent)>'}, '<android.util.Log: int w(java.lang.String,java.lang.String)>': {'code': '  w  None', 'parent': 'Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>'}, '<androidx.core.app.ActivityCompat: androidx.core.app.ActivityCompat$PermissionCompatDelegate getPermissionCompatDelegate()>': {'code': '  getPermissionCompatDelegate  {\n        return sDelegate;\n    }', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onActivityResult(int,int,android.content.Intent)>'}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onActivityResult(int,int,android.content.Intent)>': {'code': 'void  onActivityResult(int,int,android.content.Intent)  {\n        this.mFragments.noteStateNotSaved();\n        int requestIndex = requestCode >> 16;\n        if (requestIndex != 0) {\n            int requestIndex2 = requestIndex - 1;\n            String who = this.mPendingFragmentActivityResults.get(requestIndex2);\n            this.mPendingFragmentActivityResults.remove(requestIndex2);\n            if (who == null) {\n                Log.w(TAG, "Activity result delivered for unknown Fragment.");\n                return;\n            }\n            Fragment targetFragment = this.mFragments.findFragmentByWho(who);\n            if (targetFragment == null) {\n                Log.w(TAG, "Activity result no fragment exists for who: " + who);\n                return;\n            } else {\n                targetFragment.onActivityResult(65535 & requestCode, resultCode, data);\n                return;\n            }\n        }\n        ActivityCompat.PermissionCompatDelegate delegate = ActivityCompat.getPermissionCompatDelegate();\n        if (delegate == null || !delegate.onActivityResult(this, requestCode, resultCode, data)) {\n            super.onActivityResult(requestCode, resultCode, data);\n        }\n    }', 'children': ['<androidx.core.content.ContextCompat: void <clinit>()>', '<java.lang.StringBuilder: java.lang.String toString()>', '<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>', '<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>', '<java.lang.StringBuilder: void <init>()>', '<android.util.Log: int w(java.lang.String,java.lang.String)>', '<android.util.Log: int w(java.lang.String,java.lang.String)>', '<androidx.core.app.ActivityCompat: androidx.core.app.ActivityCompat$PermissionCompatDelegate getPermissionCompatDelegate()>']}, '<android.os.Build$VERSION: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onBackPressed()>'}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onBackPressed()>': {'code': 'void  onBackPressed()  {\n        FragmentManager fragmentManager = this.mFragments.getSupportFragmentManager();\n        boolean isStateSaved = fragmentManager.isStateSaved();\n        if (!isStateSaved || Build.VERSION.SDK_INT > 25) {\n            if (isStateSaved || !fragmentManager.popBackStackImmediate()) {\n                super.onBackPressed();\n            }\n        }\n    }', 'children': ['<android.os.Build$VERSION: void <clinit>()>']}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onConfigurationChanged(android.content.res.Configuration)>': {'code': 'void  onConfigurationChanged(android.content.res.Configuration)  {\n        super.onConfigurationChanged(newConfig);\n        this.mFragments.noteStateNotSaved();\n        this.mFragments.dispatchConfigurationChanged(newConfig);\n    }', 'children': []}, '<androidx.collection.SparseArrayCompat: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>'}, '<androidx.collection.SparseArrayCompat: void put(int,java.lang.Object)>': {'code': '  put  {\n        int i = ContainerHelpers.binarySearch(this.mKeys, this.mSize, key);\n        if (i >= 0) {\n            this.mValues[i] = value;\n            return;\n        }\n        int i2 = i ^ (-1);\n        if (i2 < this.mSize && this.mValues[i2] == DELETED) {\n            this.mKeys[i2] = key;\n            this.mValues[i2] = value;\n            return;\n        }\n        if (this.mGarbage && this.mSize >= this.mKeys.length) {\n            gc();\n            i2 = ContainerHelpers.binarySearch(this.mKeys, this.mSize, key) ^ (-1);\n        }\n        if (this.mSize >= this.mKeys.length) {\n            int n = ContainerHelpers.idealIntArraySize(this.mSize + 1);\n            int[] nkeys = new int[n];\n            Object[] nvalues = new Object[n];\n            System.arraycopy(this.mKeys, 0, nkeys, 0, this.mKeys.length);\n            System.arraycopy(this.mValues, 0, nvalues, 0, this.mValues.length);\n            this.mKeys = nkeys;\n            this.mValues = nvalues;\n        }\n        if (this.mSize - i2 != 0) {\n            System.arraycopy(this.mKeys, i2, this.mKeys, i2 + 1, this.mSize - i2);\n            System.arraycopy(this.mValues, i2, this.mValues, i2 + 1, this.mSize - i2);\n        }\n        this.mKeys[i2] = key;\n        this.mValues[i2] = value;\n        this.mSize++;\n    }', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>'}, '<androidx.collection.SparseArrayCompat: void <init>(int)>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>'}, '<androidx.collection.SparseArrayCompat: void <init>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>'}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        this.mFragments.attachHost(null);\n        super.onCreate(savedInstanceState);\n        NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance();\n        if (nc != null && nc.viewModelStore != null && this.mViewModelStore == null) {\n            this.mViewModelStore = nc.viewModelStore;\n        }\n        if (savedInstanceState != null) {\n            Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);\n            this.mFragments.restoreAllState(p, nc != null ? nc.fragments : null);\n            if (savedInstanceState.containsKey(NEXT_CANDIDATE_REQUEST_INDEX_TAG)) {\n                this.mNextCandidateRequestIndex = savedInstanceState.getInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG);\n                int[] requestCodes = savedInstanceState.getIntArray(ALLOCATED_REQUEST_INDICIES_TAG);\n                String[] fragmentWhos = savedInstanceState.getStringArray(REQUEST_FRAGMENT_WHO_TAG);\n                if (requestCodes == null || fragmentWhos == null || requestCodes.length != fragmentWhos.length) {\n                    Log.w(TAG, "Invalid requestCode mapping in savedInstanceState.");\n                } else {\n                    this.mPendingFragmentActivityResults = new SparseArrayCompat<>(requestCodes.length);\n                    for (int i = 0; i < requestCodes.length; i++) {\n                        this.mPendingFragmentActivityResults.put(requestCodes[i], fragmentWhos[i]);\n                    }\n                }\n            }\n        }\n        if (this.mPendingFragmentActivityResults == null) {\n            this.mPendingFragmentActivityResults = new SparseArrayCompat<>();\n            this.mNextCandidateRequestIndex = 0;\n        }\n        this.mFragments.dispatchCreate();\n    }', 'children': ['<androidx.collection.SparseArrayCompat: void <clinit>()>', '<androidx.collection.SparseArrayCompat: void put(int,java.lang.Object)>', '<androidx.collection.SparseArrayCompat: void <init>(int)>', '<androidx.collection.SparseArrayCompat: void <init>()>', '<androidx.collection.SparseArrayCompat: void <clinit>()>', '<android.util.Log: int w(java.lang.String,java.lang.String)>']}, 'Entry-point: <androidx.fragment.app.FragmentActivity: boolean onCreatePanelMenu(int,android.view.Menu)>': {'code': 'boolean  onCreatePanelMenu(int,android.view.Menu)  {\n        if (featureId == 0) {\n            boolean show = super.onCreatePanelMenu(featureId, menu);\n            return show | this.mFragments.dispatchCreateOptionsMenu(menu, getMenuInflater());\n        }\n        boolean show2 = super.onCreatePanelMenu(featureId, menu);\n        return show2;\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onDestroy()>': {'code': 'void  onDestroy()  {\n        super.onDestroy();\n        if (this.mViewModelStore != null && !isChangingConfigurations()) {\n            this.mViewModelStore.clear();\n        }\n        this.mFragments.dispatchDestroy();\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onLowMemory()>': {'code': 'void  onLowMemory()  {\n        super.onLowMemory();\n        this.mFragments.dispatchLowMemory();\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: boolean onMenuItemSelected(int,android.view.MenuItem)>': {'code': 'boolean  onMenuItemSelected(int,android.view.MenuItem)  {\n        if (super.onMenuItemSelected(featureId, item)) {\n            return true;\n        }\n        switch (featureId) {\n            case 0:\n                return this.mFragments.dispatchOptionsItemSelected(item);\n            case 6:\n                return this.mFragments.dispatchContextItemSelected(item);\n            default:\n                return false;\n        }\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onMultiWindowModeChanged(boolean)>': {'code': 'void  onMultiWindowModeChanged(boolean)  {\n        this.mFragments.dispatchMultiWindowModeChanged(isInMultiWindowMode);\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onNewIntent(android.content.Intent)>': {'code': 'void  onNewIntent(android.content.Intent)  {\n        super.onNewIntent(intent);\n        this.mFragments.noteStateNotSaved();\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onPanelClosed(int,android.view.Menu)>': {'code': 'void  onPanelClosed(int,android.view.Menu)  {\n        switch (featureId) {\n            case 0:\n                this.mFragments.dispatchOptionsMenuClosed(menu);\n                break;\n        }\n        super.onPanelClosed(featureId, menu);\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onPause()>': {'code': 'void  onPause()  {\n        super.onPause();\n        this.mResumed = false;\n        if (this.mHandler.hasMessages(2)) {\n            this.mHandler.removeMessages(2);\n            onResumeFragments();\n        }\n        this.mFragments.dispatchPause();\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onPictureInPictureModeChanged(boolean)>': {'code': 'void  onPictureInPictureModeChanged(boolean)  {\n        this.mFragments.dispatchPictureInPictureModeChanged(isInPictureInPictureMode);\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onPostResume()>': {'code': 'void  onPostResume()  {\n        super.onPostResume();\n        this.mHandler.removeMessages(2);\n        onResumeFragments();\n        this.mFragments.execPendingActions();\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: boolean onPreparePanel(int,android.view.View,android.view.Menu)>': {'code': 'boolean  onPreparePanel(int,android.view.View,android.view.Menu)  {\n        if (featureId == 0 && menu != null) {\n            boolean goforit = onPrepareOptionsPanel(view, menu);\n            return goforit | this.mFragments.dispatchPrepareOptionsMenu(menu);\n        }\n        boolean goforit2 = super.onPreparePanel(featureId, view, menu);\n        return goforit2;\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>': {'code': 'void  onRequestPermissionsResult(int,java.lang.String[],int[])  {\n        this.mFragments.noteStateNotSaved();\n        int index = (requestCode >> 16) & SupportMenu.USER_MASK;\n        if (index != 0) {\n            int index2 = index - 1;\n            String who = this.mPendingFragmentActivityResults.get(index2);\n            this.mPendingFragmentActivityResults.remove(index2);\n            if (who == null) {\n                Log.w(TAG, "Activity result delivered for unknown Fragment.");\n                return;\n            }\n            Fragment frag = this.mFragments.findFragmentByWho(who);\n            if (frag == null) {\n                Log.w(TAG, "Activity result no fragment exists for who: " + who);\n            } else {\n                frag.onRequestPermissionsResult(requestCode & SupportMenu.USER_MASK, permissions, grantResults);\n            }\n        }\n    }', 'children': ['<android.util.Log: int w(java.lang.String,java.lang.String)>', '<java.lang.StringBuilder: java.lang.String toString()>', '<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>', '<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>', '<java.lang.StringBuilder: void <init>()>', '<android.util.Log: int w(java.lang.String,java.lang.String)>']}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onResume()>': {'code': 'void  onResume()  {\n        super.onResume();\n        this.mHandler.sendEmptyMessage(2);\n        this.mResumed = true;\n        this.mFragments.execPendingActions();\n    }', 'children': []}, '<java.lang.String: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void onSaveInstanceState(android.os.Bundle)>'}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onSaveInstanceState(android.os.Bundle)>': {'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        super.onSaveInstanceState(outState);\n        markFragmentsCreated();\n        Parcelable p = this.mFragments.saveAllState();\n        if (p != null) {\n            outState.putParcelable(FRAGMENTS_TAG, p);\n        }\n        if (this.mPendingFragmentActivityResults.size() > 0) {\n            outState.putInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG, this.mNextCandidateRequestIndex);\n            int[] requestCodes = new int[this.mPendingFragmentActivityResults.size()];\n            String[] fragmentWhos = new String[this.mPendingFragmentActivityResults.size()];\n            for (int i = 0; i < this.mPendingFragmentActivityResults.size(); i++) {\n                requestCodes[i] = this.mPendingFragmentActivityResults.keyAt(i);\n                fragmentWhos[i] = this.mPendingFragmentActivityResults.valueAt(i);\n            }\n            outState.putIntArray(ALLOCATED_REQUEST_INDICIES_TAG, requestCodes);\n            outState.putStringArray(REQUEST_FRAGMENT_WHO_TAG, fragmentWhos);\n        }\n    }', 'children': ['<java.lang.String: void <clinit>()>']}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onStart()>': {'code': 'void  onStart()  {\n        super.onStart();\n        this.mStopped = false;\n        if (!this.mCreated) {\n            this.mCreated = true;\n            this.mFragments.dispatchActivityCreated();\n        }\n        this.mFragments.noteStateNotSaved();\n        this.mFragments.execPendingActions();\n        this.mFragments.dispatchStart();\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onStateNotSaved()>': {'code': 'void  onStateNotSaved()  {\n        this.mFragments.noteStateNotSaved();\n    }', 'children': []}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onStop()>': {'code': 'void  onStop()  {\n        super.onStop();\n        this.mStopped = true;\n        markFragmentsCreated();\n        this.mFragments.dispatchStop();\n    }', 'children': []}, '<android.app.Activity: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>'}, '<androidx.fragment.app.FragmentActivity: void checkForValidRequestCode(int)>': {'code': '  checkForValidRequestCode  {\n        if (((-65536) & requestCode) != 0) {\n            throw new IllegalArgumentException("Can only use lower 16 bits for requestCode");\n        }\n    }', 'parent': 'Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>'}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void startActivityForResult(android.content.Intent,int)>': {'code': 'void  startActivityForResult(android.content.Intent,int)  {\n        if (!this.mStartedActivityFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startActivityForResult(intent, requestCode);\n    }', 'children': ['<android.app.Activity: void <clinit>()>', '<androidx.fragment.app.FragmentActivity: void checkForValidRequestCode(int)>']}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void startActivityForResult(android.content.Intent,int,android.os.Bundle)>': {'code': 'void  startActivityForResult(android.content.Intent,int,android.os.Bundle)  {\n        if (!this.mStartedActivityFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startActivityForResult(intent, requestCode);\n    }', 'children': ['<android.app.Activity: void <clinit>()>', '<androidx.fragment.app.FragmentActivity: void checkForValidRequestCode(int)>']}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)>': {'code': 'void  startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)  {\n        if (!this.mStartedIntentSenderFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);\n    }', 'children': ['<android.app.Activity: void <clinit>()>', '<androidx.fragment.app.FragmentActivity: void checkForValidRequestCode(int)>']}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>': {'code': 'void  startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)  {\n        if (!this.mStartedIntentSenderFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);\n    }', 'children': ['<android.app.Activity: void <clinit>()>', '<androidx.fragment.app.FragmentActivity: void checkForValidRequestCode(int)>']}, '<androidx.core.view.KeyEventDispatcher: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>'}, '<androidx.core.view.KeyEventDispatcher: boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent)>': {'code': '  dispatchBeforeHierarchy  {\n        return ViewCompat.dispatchUnhandledKeyEventBeforeHierarchy(root, event);\n    }', 'parent': 'Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>'}, '<androidx.core.view.KeyEventDispatcher: boolean dispatchKeyEvent(androidx.core.view.KeyEventDispatcher$Component,android.view.View,android.view.Window$Callback,android.view.KeyEvent)>': {'code': '  dispatchKeyEvent  {\n        if (component == null) {\n            return false;\n        }\n        if (Build.VERSION.SDK_INT >= 28) {\n            return component.superDispatchKeyEvent(event);\n        }\n        if (callback instanceof Activity) {\n            return activitySuperDispatchKeyEventPre28((Activity) callback, event);\n        }\n        if (callback instanceof Dialog) {\n            return dialogSuperDispatchKeyEventPre28((Dialog) callback, event);\n        }\n        return (root != null && ViewCompat.dispatchUnhandledKeyEventBeforeCallback(root, event)) || component.superDispatchKeyEvent(event);\n    }', 'parent': 'Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyEvent(android.view.KeyEvent)>'}, 'Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyEvent(android.view.KeyEvent)>': {'code': 'boolean  dispatchKeyEvent(android.view.KeyEvent)  {\n        View decor = getWindow().getDecorView();\n        if (decor == null || !KeyEventDispatcher.dispatchBeforeHierarchy(decor, event)) {\n            return KeyEventDispatcher.dispatchKeyEvent(this, decor, this, event);\n        }\n        return true;\n    }', 'children': ['<androidx.core.view.KeyEventDispatcher: void <clinit>()>', '<androidx.core.view.KeyEventDispatcher: void <clinit>()>', '<androidx.core.view.KeyEventDispatcher: boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent)>', '<androidx.core.view.KeyEventDispatcher: boolean dispatchKeyEvent(androidx.core.view.KeyEventDispatcher$Component,android.view.View,android.view.Window$Callback,android.view.KeyEvent)>']}, 'Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>': {'code': 'boolean  dispatchKeyShortcutEvent(android.view.KeyEvent)  {\n        View decor = getWindow().getDecorView();\n        if (decor == null || !KeyEventDispatcher.dispatchBeforeHierarchy(decor, event)) {\n            return super.dispatchKeyShortcutEvent(event);\n        }\n        return true;\n    }', 'children': ['<androidx.core.view.KeyEventDispatcher: void <clinit>()>', '<androidx.core.view.KeyEventDispatcher: boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent)>']}, '<androidx.lifecycle.ReportFragment: void injectIfNeededIn(android.app.Activity)>': {'code': '  injectIfNeededIn  {\n        FragmentManager manager = activity.getFragmentManager();\n        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\n            manager.executePendingTransactions();\n        }\n    }', 'parent': 'Entry-point: <androidx.core.app.ComponentActivity: void onCreate(android.os.Bundle)>'}, 'Entry-point: <androidx.core.app.ComponentActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n    }', 'children': ['<androidx.lifecycle.ReportFragment: void injectIfNeededIn(android.app.Activity)>']}, '<androidx.lifecycle.Lifecycle$State: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <androidx.core.app.ComponentActivity: void onSaveInstanceState(android.os.Bundle)>'}, 'Entry-point: <androidx.core.app.ComponentActivity: void onSaveInstanceState(android.os.Bundle)>': {'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        this.mLifecycleRegistry.markState(Lifecycle.State.CREATED);\n        super.onSaveInstanceState(outState);\n    }', 'children': ['<androidx.lifecycle.Lifecycle$State: void <clinit>()>']}, 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onBackPressed()>': {'code': 'void  onBackPressed()  {\n        if (this.message != null) {\n            this.message.isVisible = false;\n            this.message.viewed();\n        }\n        finish();\n        overridePendingTransition(0, 0);\n    }', 'children': []}, '<com.adobe.mobile.Messages: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>'}, '<android.widget.RelativeLayout: void <init>(android.content.Context)>': {'code': '    None', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>'}, '<android.view.View: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>'}, '<com.adobe.mobile.Messages: void setCurrentMessageFullscreen(com.adobe.mobile.MessageFullScreen)>': {'code': '  setCurrentMessageFullscreen  {\n        synchronized (_messageFullScreenMutex) {\n            _messageFullScreen = message;\n        }\n    }', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>'}, '<com.adobe.mobile.Messages: com.adobe.mobile.MessageFullScreen getCurrentFullscreenMessage()>': {'code': '  getCurrentFullscreenMessage  {\n        MessageFullScreen messageFullScreen;\n        synchronized (_messageFullScreenMutex) {\n            messageFullScreen = _messageFullScreen;\n        }\n        return messageFullScreen;\n    }', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>'}, 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState != null) {\n            this.message = restoreFromSavedState(savedInstanceState);\n            Messages.setCurrentMessageFullscreen(this.message);\n        } else {\n            this.message = Messages.getCurrentFullscreenMessage();\n        }\n        if (messageIsValid()) {\n            this.message.messageFullScreenActivity = this;\n            requestWindowFeature(1);\n            RelativeLayout relativeLayout = new RelativeLayout(this);\n            setContentView(relativeLayout);\n        }\n    }', 'children': ['<com.adobe.mobile.Messages: void <clinit>()>', '<android.widget.RelativeLayout: void <init>(android.content.Context)>', '<com.adobe.mobile.Messages: void <clinit>()>', '<android.view.View: void <clinit>()>', '<com.adobe.mobile.Messages: void setCurrentMessageFullscreen(com.adobe.mobile.MessageFullScreen)>', '<com.adobe.mobile.Messages: com.adobe.mobile.MessageFullScreen getCurrentFullscreenMessage()>']}, '<com.adobe.mobile.StaticMethods: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>'}, '<java.lang.Throwable: java.lang.String getMessage()>': {'code': '  getMessage  None', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>'}, '<com.adobe.mobile.MessageFullScreenActivity$1: void run()>': {'code': '  run  None', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>'}, '<com.adobe.mobile.MessageFullScreenActivity$1: void <init>(com.adobe.mobile.MessageFullScreenActivity,android.view.ViewGroup)>': {'code': '    None', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>'}, '<com.adobe.mobile.StaticMethods: void logErrorFormat(java.lang.String,java.lang.Object[])>': {'code': '  logErrorFormat  {\n        if (args != null && args.length > 0) {\n            String formattedString = String.format("ADBMobile Error : " + format, args);\n            Log.e("ADBMobile", formattedString);\n            return;\n        }\n        Log.e("ADBMobile", "ADBMobile Error : " + format);\n    }', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>'}, '<com.adobe.mobile.StaticMethods: void logWarningFormat(java.lang.String,java.lang.Object[])>': {'code': '  logWarningFormat  {\n        if (getDebugLogging()) {\n            if (args != null && args.length > 0) {\n                String formattedString = String.format("ADBMobile Warning : " + format, args);\n                Log.w("ADBMobile", formattedString);\n                return;\n            }\n            Log.w("ADBMobile", "ADBMobile Warning : " + format);\n        }\n    }', 'parent': 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>'}, 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>': {'code': 'void  onResume()  {\n        super.onResume();\n        if (messageIsValid()) {\n            try {\n                final ViewGroup rootViewGroup = (ViewGroup) findViewById(16908290);\n                if (rootViewGroup == null) {\n                    StaticMethods.logErrorFormat("Messages - unable to get root view group from os", new Object[0]);\n                    finish();\n                    overridePendingTransition(0, 0);\n                } else {\n                    rootViewGroup.post(new Runnable() { // from class: com.adobe.mobile.MessageFullScreenActivity.1\n                        @Override // java.lang.Runnable\n                        public void run() {\n                            MessageFullScreenActivity.this.message.rootViewGroup = rootViewGroup;\n                            MessageFullScreenActivity.this.message.showInRootViewGroup();\n                        }\n                    });\n                }\n            } catch (NullPointerException ex) {\n                StaticMethods.logWarningFormat("Messages - content view is in undefined state (%s)", ex.getMessage());\n                finish();\n                overridePendingTransition(0, 0);\n            }\n        }\n    }', 'children': ['<com.adobe.mobile.StaticMethods: void <clinit>()>', '<java.lang.Throwable: java.lang.String getMessage()>', '<com.adobe.mobile.MessageFullScreenActivity$1: void run()>', '<com.adobe.mobile.MessageFullScreenActivity$1: void <init>(com.adobe.mobile.MessageFullScreenActivity,android.view.ViewGroup)>', '<com.adobe.mobile.StaticMethods: void <clinit>()>', '<com.adobe.mobile.StaticMethods: void logErrorFormat(java.lang.String,java.lang.Object[])>', '<com.adobe.mobile.StaticMethods: void logWarningFormat(java.lang.String,java.lang.Object[])>']}, 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onSaveInstanceState(android.os.Bundle)>': {'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        outState.putString(MESSAGE_STATE_MESSAGE_ID, this.message.messageId);\n        outState.putString(MESSAGE_STATE_REPLACED_HTML, this.message.replacedHtml);\n        super.onSaveInstanceState(outState);\n    }', 'children': []}, '<com.adobe.mobile.Config: void setContext(android.content.Context)>': {'code': '  setContext  {\n        setContext(context, ApplicationType.APPLICATION_TYPE_HANDHELD);\n    }', 'parent': 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onCreate(android.os.Bundle)>'}, 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        Config.setContext(getApplicationContext());\n    }', 'children': ['<com.adobe.mobile.Config: void setContext(android.content.Context)>']}, '<com.adobe.mobile.Config: void pauseCollectingLifecycleData()>': {'code': '  pauseCollectingLifecycleData  {\n        if (StaticMethods.isWearableApp()) {\n            StaticMethods.logWarningFormat("Analytics - Method pauseCollectingLifecycleData is not available for Wearable", new Object[0]);\n            return;\n        }\n        MessageAlert.clearCurrentDialog();\n        StaticMethods.getAnalyticsExecutor().execute(new Runnable() { // from class: com.adobe.mobile.Config.12\n            @Override // java.lang.Runnable\n            public void run() {\n                Lifecycle.stop();\n            }\n        });\n    }', 'parent': 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onPause()>'}, 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onPause()>': {'code': 'void  onPause()  {\n        super.onPause();\n        Config.pauseCollectingLifecycleData();\n    }', 'children': ['<com.adobe.mobile.Config: void pauseCollectingLifecycleData()>']}, '<com.adobe.mobile.Config: void collectLifecycleData(android.app.Activity)>': {'code': '  collectLifecycleData  {\n        if (StaticMethods.isWearableApp()) {\n            StaticMethods.logWarningFormat("Analytics - Method collectLifecycleData is not available for Wearable", new Object[0]);\n        } else {\n            StaticMethods.getAnalyticsExecutor().execute(new Runnable() { // from class: com.adobe.mobile.Config.9\n                @Override // java.lang.Runnable\n                public void run() {\n                    Lifecycle.start(null, null);\n                }\n            });\n        }\n    }', 'parent': 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onResume()>'}, 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onResume()>': {'code': 'void  onResume()  {\n        super.onResume();\n        Config.collectLifecycleData(this);\n    }', 'children': ['<com.adobe.mobile.Config: void collectLifecycleData(android.app.Activity)>']}, '<com.google.android.gms.common.api.internal.GoogleApiManager: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>'}, '<com.google.android.gms.common.ConnectionResult: void <init>(int,android.app.PendingIntent)>': {'code': '    None', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>'}, '<com.google.android.gms.common.api.internal.GoogleApiManager: void zao()>': {'code': '  zao  {\n        this.handler.sendMessage(this.handler.obtainMessage(3));\n    }', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>'}, '<com.google.android.gms.common.api.internal.GoogleApiManager: void zaa(com.google.android.gms.common.ConnectionResult,int)>': {'code': '  zaa  {\n            if (iAccountAccessor == null || set == null) {\n                Log.wtf("GoogleApiManager", "Received null response from onSignInSuccess", new Exception());\n                zag(new ConnectionResult(4));\n                return;\n            }\n            this.zajd = iAccountAccessor;\n            this.zaje = set;\n            zabr();\n        }', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>'}, '<com.google.android.gms.common.ConnectionResult: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>'}, '<com.google.android.gms.common.api.internal.GoogleApiManager: com.google.android.gms.common.api.internal.GoogleApiManager zab(android.content.Context)>': {'code': '  zab  {\n        GoogleApiManager googleApiManager;\n        synchronized (lock) {\n            if (zaic == null) {\n                HandlerThread handlerThread = new HandlerThread("GoogleApiHandler", 9);\n                handlerThread.start();\n                zaic = new GoogleApiManager(context.getApplicationContext(), handlerThread.getLooper(), GoogleApiAvailability.getInstance());\n            }\n            googleApiManager = zaic;\n        }\n        return googleApiManager;\n    }', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>'}, 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>': {'code': 'void  onActivityResult(int,int,android.content.Intent)  {\n        super.onActivityResult(i, i2, intent);\n        if (i == 1) {\n            boolean booleanExtra = getIntent().getBooleanExtra("notify_manager", true);\n            this.zabp = 0;\n            setResult(i2, intent);\n            if (booleanExtra) {\n                GoogleApiManager zab = GoogleApiManager.zab(this);\n                switch (i2) {\n                    case -1:\n                        zab.zao();\n                        break;\n                    case 0:\n                        zab.zaa(new ConnectionResult(13, null), getIntent().getIntExtra("failing_client_id", -1));\n                        break;\n                }\n            }\n        } else if (i == 2) {\n            this.zabp = 0;\n            setResult(i2, intent);\n        }\n        finish();\n    }', 'children': ['<com.google.android.gms.common.api.internal.GoogleApiManager: void <clinit>()>', '<com.google.android.gms.common.ConnectionResult: void <init>(int,android.app.PendingIntent)>', '<com.google.android.gms.common.api.internal.GoogleApiManager: void zao()>', '<com.google.android.gms.common.api.internal.GoogleApiManager: void zaa(com.google.android.gms.common.ConnectionResult,int)>', '<com.google.android.gms.common.ConnectionResult: void <clinit>()>', '<com.google.android.gms.common.api.internal.GoogleApiManager: com.google.android.gms.common.api.internal.GoogleApiManager zab(android.content.Context)>']}, '<com.google.android.gms.common.GoogleApiAvailability: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>'}, '<com.google.android.gms.common.GoogleApiAvailability: boolean showErrorDialogFragment(android.app.Activity,int,int,android.content.DialogInterface$OnCancelListener)>': {'code': '  showErrorDialogFragment  {\n        return showErrorDialogFragment(activity, i, i2, null);\n    }', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>'}, '<com.google.android.gms.common.GoogleApiAvailabilityLight: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>'}, '<android.util.Log: int e(java.lang.String,java.lang.String)>': {'code': '  e  None', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>'}, '<android.util.Log: int e(java.lang.String,java.lang.String,java.lang.Throwable)>': {'code': '  e  None', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>'}, '<com.google.android.gms.common.GoogleApiAvailability: com.google.android.gms.common.GoogleApiAvailability getInstance()>': {'code': '  getInstance  {\n        return zaao;\n    }', 'parent': 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>'}, 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(bundle);\n        if (bundle != null) {\n            this.zabp = bundle.getInt("resolution");\n        }\n        if (this.zabp != 1) {\n            Bundle extras = getIntent().getExtras();\n            if (extras == null) {\n                Log.e("GoogleApiActivity", "Activity started without extras");\n                finish();\n                return;\n            }\n            PendingIntent pendingIntent = (PendingIntent) extras.get("pending_intent");\n            Integer num = (Integer) extras.get("error_code");\n            if (pendingIntent == null && num == null) {\n                Log.e("GoogleApiActivity", "Activity started without resolution");\n                finish();\n            } else if (pendingIntent != null) {\n                try {\n                    startIntentSenderForResult(pendingIntent.getIntentSender(), 1, null, 0, 0, 0);\n                    this.zabp = 1;\n                } catch (IntentSender.SendIntentException e) {\n                    Log.e("GoogleApiActivity", "Failed to launch pendingIntent", e);\n                    finish();\n                }\n            } else {\n                GoogleApiAvailability.getInstance().showErrorDialogFragment(this, num.intValue(), 2, this);\n                this.zabp = 1;\n            }\n        }\n    }', 'children': ['<com.google.android.gms.common.GoogleApiAvailability: void <clinit>()>', '<com.google.android.gms.common.GoogleApiAvailability: boolean showErrorDialogFragment(android.app.Activity,int,int,android.content.DialogInterface$OnCancelListener)>', '<com.google.android.gms.common.GoogleApiAvailabilityLight: void <clinit>()>', '<android.util.Log: int e(java.lang.String,java.lang.String)>', '<android.util.Log: int e(java.lang.String,java.lang.String)>', '<android.util.Log: int e(java.lang.String,java.lang.String,java.lang.Throwable)>', '<com.google.android.gms.common.GoogleApiAvailability: com.google.android.gms.common.GoogleApiAvailability getInstance()>']}, 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onSaveInstanceState(android.os.Bundle)>': {'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        bundle.putInt("resolution", this.zabp);\n        super.onSaveInstanceState(bundle);\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerNativeActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        Log.w("Unity", "UnityPlayerNativeActivity has been deprecated, please update your AndroidManifest to use UnityPlayerActivity instead");\n        super.onCreate(bundle);\n    }', 'children': ['<android.util.Log: int w(java.lang.String,java.lang.String)>']}, '<com.unity3d.player.UnityPlayer: void <clinit>()>': {'code': '    None', 'parent': 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>'}, '<net.gree.unitywebview.CUnityPlayer: void <init>(android.content.ContextWrapper)>': {'code': '    None', 'parent': 'Entry-point: <net.gree.unitywebview.CUnityPlayerActivity: void onCreate(android.os.Bundle)>'}, 'Entry-point: <net.gree.unitywebview.CUnityPlayerActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        requestWindowFeature(1);\n        super.onCreate(bundle);\n        getWindow().setFormat(2);\n        this.mUnityPlayer = new CUnityPlayer(this);\n        setContentView(this.mUnityPlayer);\n        this.mUnityPlayer.requestFocus();\n    }', 'children': ['<com.unity3d.player.UnityPlayer: void <clinit>()>', '<net.gree.unitywebview.CUnityPlayer: void <init>(android.content.ContextWrapper)>', '<android.view.View: void <clinit>()>']}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean dispatchKeyEvent(android.view.KeyEvent)>': {'code': 'boolean  dispatchKeyEvent(android.view.KeyEvent)  {\n        return keyEvent.getAction() == 2 ? this.mUnityPlayer.injectEvent(keyEvent) : super.dispatchKeyEvent(keyEvent);\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onConfigurationChanged(android.content.res.Configuration)>': {'code': 'void  onConfigurationChanged(android.content.res.Configuration)  {\n        super.onConfigurationChanged(configuration);\n        this.mUnityPlayer.configurationChanged(configuration);\n    }', 'children': []}, '<android.view.View: boolean requestFocus()>': {'code': '  requestFocus  None', 'parent': 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>'}, '<com.unity3d.player.UnityPlayer: void <init>(android.content.Context)>': {'code': '    None', 'parent': 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>'}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        requestWindowFeature(1);\n        super.onCreate(bundle);\n        this.mUnityPlayer = new UnityPlayer(this);\n        setContentView(this.mUnityPlayer);\n        this.mUnityPlayer.requestFocus();\n    }', 'children': ['<com.unity3d.player.UnityPlayer: void <clinit>()>', '<android.view.View: boolean requestFocus()>', '<com.unity3d.player.UnityPlayer: void <init>(android.content.Context)>', '<android.view.View: void <clinit>()>']}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onDestroy()>': {'code': 'void  onDestroy()  {\n        this.mUnityPlayer.quit();\n        super.onDestroy();\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean onGenericMotionEvent(android.view.MotionEvent)>': {'code': 'boolean  onGenericMotionEvent(android.view.MotionEvent)  {\n        return this.mUnityPlayer.injectEvent(motionEvent);\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean onKeyDown(int,android.view.KeyEvent)>': {'code': 'boolean  onKeyDown(int,android.view.KeyEvent)  {\n        return this.mUnityPlayer.injectEvent(keyEvent);\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean onKeyUp(int,android.view.KeyEvent)>': {'code': 'boolean  onKeyUp(int,android.view.KeyEvent)  {\n        return this.mUnityPlayer.injectEvent(keyEvent);\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onLowMemory()>': {'code': 'void  onLowMemory()  {\n        super.onLowMemory();\n        this.mUnityPlayer.lowMemory();\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onNewIntent(android.content.Intent)>': {'code': 'void  onNewIntent(android.content.Intent)  {\n        setIntent(intent);\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onPause()>': {'code': 'void  onPause()  {\n        super.onPause();\n        this.mUnityPlayer.pause();\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onResume()>': {'code': 'void  onResume()  {\n        super.onResume();\n        this.mUnityPlayer.resume();\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onStart()>': {'code': 'void  onStart()  {\n        super.onStart();\n        this.mUnityPlayer.start();\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onStop()>': {'code': 'void  onStop()  {\n        super.onStop();\n        this.mUnityPlayer.stop();\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>': {'code': 'boolean  onTouchEvent(android.view.MotionEvent)  {\n        return this.mUnityPlayer.injectEvent(motionEvent);\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onTrimMemory(int)>': {'code': 'void  onTrimMemory(int)  {\n        super.onTrimMemory(i);\n        if (i == 15) {\n            this.mUnityPlayer.lowMemory();\n        }\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onWindowFocusChanged(boolean)>': {'code': 'void  onWindowFocusChanged(boolean)  {\n        super.onWindowFocusChanged(z);\n        this.mUnityPlayer.windowFocusChanged(z);\n    }', 'children': []}, 'Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>': {'code': 'void  onCreate(android.os.Bundle)  {\n        Log.w("Unity", "UnityPlayerProxyActivity has been deprecated, please update your AndroidManifest to use UnityPlayerActivity instead");\n        super.onCreate(bundle);\n    }', 'children': ['<android.util.Log: int w(java.lang.String,java.lang.String)>']}}
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function not found: java.lang.String toString()
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function not found: java.lang.StringBuilder append(java.lang.String)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function not found: java.lang.StringBuilder append(java.lang.String)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function not found: void init()
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>
Sending request to server...
Response received!
Summarized child function:  It first prints a prefix, then it prints the value of the'mId' field, then it prints the value of the'mArgs' field, then it prints the loader, and finally it dumps the loader's data. The provided code is designed to provide a concise and readable representation of the Loader's internal state.
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>
Sending request to server...
Response received!
Summarized child function:  It calculates the hash code of the object 'None' using the 'identityHashCode' method, which returns the same hash code for every 'None' instance.
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>
Sending request to server...
Response received!
Summarized child function:  It converts a number to a hexadecimal string representation. However, it does not provide any input validation, so it's possible to generate an invalid hexadecimal string if the input is not a number. For example, calling `toHexString(NaN)` will generate the string 'NaN', which is not a valid hexadecimal string.
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>
Sending request to server...
Response received!
Summarized child function:  It declares a method called 'getInstance' that returns a new instance of the 'LoaderManagerImpl' class. It takes two arguments: 'owner' and'store'. The 'owner' argument is a reference to the object that owns the new instance, and the'store' argument is a reference to the View Model Store that the owner will use to store its View Models. The method first creates a new instance of the 'LoaderManagerImpl' class, and then initializes it with the provided 'owner' and'store' arguments. Finally, it returns the new instance.
Sending request to server...
Response received!
Summarized entry point function:  It first prints a prefix, then it prints the value of the'mId' field, then it prints the value of the'mArgs' field, then it prints the loader, and finally it dumps the loader's data. The provided code is designed to provide a concise and readable representation of the Loader's internal state.  It calculates the hash code of the object 'None' using the 'identityHashCode' method, which returns the same hash code for every 'None' instance.  It converts a number to a hexadecimal string representation. However, it does not provide any input validation, so it's possible to generate an invalid hexadecimal string if the input is not a number. For example, calling `toHexString(NaN)` will generate the string 'NaN', which is not a valid hexadecimal string.  It declares a method called 'getInstance' that returns a new instance of the 'LoaderManagerImpl' class. It takes two arguments: 'owner' and'store'. The 'owner' argument is a reference to the object that owns the new instance, and the'store' argument is a reference to the View Model Store that the owner will use to store its View Models. The method first creates a new instance of the 'LoaderManagerImpl' class, and then initializes it with the provided 'owner' and'store' arguments. Finally, it returns the new instance.
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void onActivityResult(int,int,android.content.Intent)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onActivityResult(int,int,android.content.Intent)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function not found: java.lang.String toString()
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function not found: java.lang.StringBuilder append(java.lang.String)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function not found: java.lang.StringBuilder append(java.lang.String)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function not found: void init()
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>
Child function not found: int w(java.lang.String,java.lang.String)
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>
Child function not found: int w(java.lang.String,java.lang.String)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onActivityResult(int,int,android.content.Intent)>
Sending request to server...
Response received!
Summarized child function:  It declares a method called 'getPermissionCompatDelegate' that returns the static'sDelegate' field. It is used to provide backwards compatibility with older versions of the Android permission API.
Entry point function code: void  onActivityResult(int,int,android.content.Intent)  {
        this.mFragments.noteStateNotSaved();
        int requestIndex = requestCode >> 16;
        if (requestIndex != 0) {
            int requestIndex2 = requestIndex - 1;
            String who = this.mPendingFragmentActivityResults.get(requestIndex2);
            this.mPendingFragmentActivityResults.remove(requestIndex2);
            if (who == null) {
                Log.w(TAG, "Activity result delivered for unknown Fragment.");
                return;
            }
            Fragment targetFragment = this.mFragments.findFragmentByWho(who);
            if (targetFragment == null) {
                Log.w(TAG, "Activity result no fragment exists for who: " + who);
                return;
            } else {
                targetFragment.onActivityResult(65535 & requestCode, resultCode, data);
                return;
            }
        }
        ActivityCompat.PermissionCompatDelegate delegate = ActivityCompat.getPermissionCompatDelegate();
        if (delegate == null || !delegate.onActivityResult(this, requestCode, resultCode, data)) {
            super.onActivityResult(requestCode, resultCode, data);
        }
    }
Sending request to server...
Response received!
Summarized entry point function:  It appears to handle activity results for Fragments, but it's not clear what it actually does. The code checks for a request code greater than 65535, which is the maximum value for a 16-bit integer. If this is true, it means the code is handling a result for a Fragment, so it divides the request code by 65536 and uses the remainder as an index into an array of pending Fragment activity results. If the index is 0, it means the activity result is not for a Fragment, so it calls the superclass method. If the index is not 0, it retrieves the name of the Fragment that the activity result is for and uses it to find the target Fragment in the Fragment manager. If the target Fragment is found, it calls the target Fragment's `onActivityResult` method with the lower 16 bits of the request code and the other parameters. If the target Fragment is not found, it logs a warning.
Not an entry point function, skipping...
Summarizing entry point: void onBackPressed()
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onBackPressed()>
Child function code is None, skipping...
Entry point function code: void  onBackPressed()  {
        FragmentManager fragmentManager = this.mFragments.getSupportFragmentManager();
        boolean isStateSaved = fragmentManager.isStateSaved();
        if (!isStateSaved || Build.VERSION.SDK_INT > 25) {
            if (isStateSaved || !fragmentManager.popBackStackImmediate()) {
                super.onBackPressed();
            }
        }
    }
Sending request to server...
Response received!
Summarized entry point function:  It first checks if the fragment manager is in a saved state, and if not, it pops the back stack. However, it only does this if the SDK version is below 26. If the SDK version is 26 or higher, it will always pop the back stack, even if it is in a saved state. This is because the new FragmentManager.popBackStackImmediate() method restores the state of the manager if it is saved, and the old method does not.
Summarizing entry point: void onConfigurationChanged(android.content.res.Configuration)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register a listener for configuration changes and then call the `dispatchConfigurationChanged` method on the `FragmentManager`. However, it does not provide any explanation as to why this is necessary or what it achieves.
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It first initializes two arrays, mKeys and mValues, with the size of the expected storage (mSize). Then it searches for the position of the given key in the array using the binarySearch method. If the key is found, it updates the value at that position. If the key is not found, it searches for a position where the key can be inserted without violating the ordering. If there is an empty position, it inserts the key-value pair there. If there is no empty position, it doubles the size of the arrays and inserts the key-value pair at the new position.
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>
Child function not found: int w(java.lang.String,java.lang.String)
Entry point function code: void  onCreate(android.os.Bundle)  {
        this.mFragments.attachHost(null);
        super.onCreate(savedInstanceState);
        NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance();
        if (nc != null && nc.viewModelStore != null && this.mViewModelStore == null) {
            this.mViewModelStore = nc.viewModelStore;
        }
        if (savedInstanceState != null) {
            Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
            this.mFragments.restoreAllState(p, nc != null ? nc.fragments : null);
            if (savedInstanceState.containsKey(NEXT_CANDIDATE_REQUEST_INDEX_TAG)) {
                this.mNextCandidateRequestIndex = savedInstanceState.getInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG);
                int[] requestCodes = savedInstanceState.getIntArray(ALLOCATED_REQUEST_INDICIES_TAG);
                String[] fragmentWhos = savedInstanceState.getStringArray(REQUEST_FRAGMENT_WHO_TAG);
                if (requestCodes == null || fragmentWhos == null || requestCodes.length != fragmentWhos.length) {
                    Log.w(TAG, "Invalid requestCode mapping in savedInstanceState.");
                } else {
                    this.mPendingFragmentActivityResults = new SparseArrayCompat<>(requestCodes.length);
                    for (int i = 0; i < requestCodes.length; i++) {
                        this.mPendingFragmentActivityResults.put(requestCodes[i], fragmentWhos[i]);
                    }
                }
            }
        }
        if (this.mPendingFragmentActivityResults == null) {
            this.mPendingFragmentActivityResults = new SparseArrayCompat<>();
            this.mNextCandidateRequestIndex = 0;
        }
        this.mFragments.dispatchCreate();
    }
Sending request to server...
Response received!
Summarized entry point function:  It first initializes a `NonConfigurationInstances` object with the last non-configuration instance (if any) and then checks if the `NonConfigurationInstances` object has a `viewModelStore` field set. If this is the case, it assigns the `viewModelStore` field of the `NonConfigurationInstances` object to the `mViewModelStore` field of the `FragmentActivity` instance. Next, it checks if there is a saved instance state in the provided `savedInstanceState` parameter. If this is the case, it restores the activity's fragments from the saved state and assigns the saved `nextCandidateRequestIndex` value to the `mNextCandidateRequestIndex` field. If there is an invalid request code mapping in the saved instance state, a `Log.w` message is printed. Finally, it initializes a `SparseArrayCompat` for pending fragment activity results and assigns it to the `mPendingFragmentActivityResults` field.
Summarizing entry point: boolean onCreatePanelMenu(int,android.view.Menu)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to create a menu item for the activity, and then dispatch the creation of the menu items to the fragments attached to the activity. The question is: why is the code dispatching the menu creation to the fragments when the activity is already creating the menu?
Summarizing entry point: void onDestroy()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It first initializes a ViewModelStore instance (this.mViewModelStore) and then checks if the Activity is not in the process of being re-created (isChangingConfigurations()). If the Activity is not being re-created, it clears the ViewModelStore instance (this.mViewModelStore.clear()). Finally, it dispatches the Activity's onDestroy() to its fragments (this.mFragments.dispatchDestroy()).
Summarizing entry point: void onLowMemory()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It's registering an `onLowMemory` callback with the Activity's FragmentManager. The callback is then invoked when the Activity's memory is low, which is detected by the Android system. The callback is then delegating the call to the Activity's base class, which in turn calls the `onLowMemory` method on the Activity. The `onLowMemory` method in the Activity is then responsible for freeing any memory that it's holding.
Summarizing entry point: boolean onMenuItemSelected(int,android.view.MenuItem)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to be a method that is called when a menu item is selected. It first checks if the item was handled by the superclass (this will be true for items in the main menu, such as "Save" or "Share"), and if not, it checks if the item is part of a fragment container (0 or 6). If so, it dispatches the item to the appropriate fragment container. If not, it returns false, indicating that the item was not handled.
Summarizing entry point: void onMultiWindowModeChanged(boolean)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It's registering a callback with the Activity's FragmentManager, which will be invoked when the multi-window mode changes. The callback is provided with a boolean parameter indicating the new multi-window mode. The callback is then dispatching the mode change to all registered Fragments using the FragmentManager's `dispatchMultiWindowModeChanged` method.
Summarizing entry point: void onNewIntent(android.content.Intent)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register an activity lifecycle callback that is used to notify the FragmentManager that the activity state has changed and not all fragments have been saved. The callback is invoked in the superclass, which in this case is Activity. In the provided code, the callback is overridden and the FragmentManager's state is explicitly saved.
Summarizing entry point: void onPanelClosed(int,android.view.Menu)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register an `onPanelClosed` callback for a specific feature ID (0). When the panel with the given feature ID is closed, the provided code dispatches the `OptionsMenu` to all registered fragments and then calls the superclass' `onPanelClosed` method. The superclass' `onPanelClosed` method is empty, so it does not actually do anything. The provided code is designed to be overridden by subclasses, so it is important to analyze it correctly.
Summarizing entry point: void onPause()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to override the `onPause` method of the Activity, which is used to pause the activity when the user switches to another application or to the home screen. The code checks if there are any pending messages with the ID 2 (which is used to indicate that the activity has been paused due to a configuration change), and if there are, it removes them and calls the `onResumeFragments` method, which is used to re-start any fragments that were stopped due to the configuration change. Finally, it dispatches the `onPause` event to all fragments in the activity.
Summarizing entry point: void onPictureInPictureModeChanged(boolean)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It's designed to dispatch a callback to the Activity or Fragment that's currently in picture-in-picture mode, which is then responsible for reacting to the change. The provided code is a no-op, which will do nothing when the callback is dispatched.
Summarizing entry point: void onPostResume()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register a `onPostResume` callback with the Activity, which is then called when the Activity is resumed after being paused. The code then removes any pending messages with ID 2 from the handler, which are used to indicate that the Activity is in the background. After that, it calls the `onResumeFragments` method, which is supposed to handle any pending Fragment transactions. Finally, it executes any pending actions on the Fragment Manager, which are used to update the UI after a configuration change.
Summarizing entry point: boolean onPreparePanel(int,android.view.View,android.view.Menu)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to be a method override in an Activity class. The method is called when the Activity is ready to show a context menu for a particular view (typically a ViewPager). The method first checks if the provided feature ID is 0, indicating that the context menu is being shown for the ViewPager. If this is true, it then checks if the provided menu is not null. If this is true, it then calls the method onPrepareOptionsPanel() and stores the result in a boolean variable 'goforit'. It then dispatches the menu preparation to the child Fragments using the FragmentManager, and stores the result in a second boolean variable 'goforit2'. The final result is the OR of the two boolean variables, which is then returned.

The provided code is designed to ensure that the child Fragments receive the menu preparation, even if the Activity's onPreparePanel() method returns false. This is necessary because the ViewPager does not call onPreparePanel() on its own, and therefore the child Fragments do not receive the menu preparation.
Summarizing entry point: void onRequestPermissionsResult(int,java.lang.String[],int[])
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>
Child function not found: int w(java.lang.String,java.lang.String)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Sending request to server...
Response received!
Summarized child function:  It converts the value of 'None' to a string 'None'. This is useful when you want to print the value of an optional variable without having to check if it is not None beforehand.
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Sending request to server...
Response received!
Summarized child function:  It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list.
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Sending request to server...
Response received!
Summarized child function:  It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list.
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>
Child function not found: int w(java.lang.String,java.lang.String)
Sending request to server...
Response received!
Summarized entry point function:  It is converting the value of 'None' to a string 'None'. This is useful when you want to print the value of an optional variable without having to check if it is not None beforehand.  It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list.
Summarizing entry point: void onResume()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register a new message (with ID 2) on the main thread's message queue, which will then be processed in the `handleMessage` method of the `FragmentActivity` class. The `onResume` method is called when the activity is resumed, which is typically when the user switches back to the app after it has been put in the background. The code then sets a flag indicating that the activity has been resumed, and finally calls the `execPendingActions` method of the `FragmentManager` to execute any pending actions that were added to the queue while the activity was paused.
Not an entry point function, skipping...
Summarizing entry point: void onSaveInstanceState(android.os.Bundle)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void onSaveInstanceState(android.os.Bundle)>
Child function code is None, skipping...
Entry point function code: void  onSaveInstanceState(android.os.Bundle)  {
        super.onSaveInstanceState(outState);
        markFragmentsCreated();
        Parcelable p = this.mFragments.saveAllState();
        if (p != null) {
            outState.putParcelable(FRAGMENTS_TAG, p);
        }
        if (this.mPendingFragmentActivityResults.size() > 0) {
            outState.putInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG, this.mNextCandidateRequestIndex);
            int[] requestCodes = new int[this.mPendingFragmentActivityResults.size()];
            String[] fragmentWhos = new String[this.mPendingFragmentActivityResults.size()];
            for (int i = 0; i < this.mPendingFragmentActivityResults.size(); i++) {
                requestCodes[i] = this.mPendingFragmentActivityResults.keyAt(i);
                fragmentWhos[i] = this.mPendingFragmentActivityResults.valueAt(i);
            }
            outState.putIntArray(ALLOCATED_REQUEST_INDICIES_TAG, requestCodes);
            outState.putStringArray(REQUEST_FRAGMENT_WHO_TAG, fragmentWhos);
        }
    }
Sending request to server...
Response received!
Summarized entry point function:  It first calls the superclass' `onSaveInstanceState()` method with the provided `Bundle` object, then it marks the fragments as created, and finally it saves the fragment states in a `Parcelable` object. If there are any pending fragment activity results, it adds the request indices, request codes, and fragment owners to the `Bundle`.
Summarizing entry point: void onStart()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It creates a new activity and starts it. It first calls the `super.onStart()` method, which is then followed by some code that initializes the activity's state and starts the fragments in the activity. The `super.onStart()` method is necessary in every Activity, and it initializes the activity's state. In this case, it initializes the `mStopped` field to `false`. The `mCreated` field is also initialized to `true`, indicating that the activity has been created. The `mFragments.dispatchActivityCreated()` method is then called, which in turn calls the `onActivityCreated()` method in all fragments attached to the activity. The `mFragments.noteStateNotSaved()` method is called to indicate that the activity's state has not been saved. The `mFragments.execPendingActions()` method is then called, which ensures that any pending actions, such as `onAttach()` or `onCreateView()` have been executed. Finally, the `mFragments.dispatchStart()` method is called, which in turn calls the `onStart()` method in all fragments attached to the activity.
Summarizing entry point: void onStateNotSaved()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register a callback with the `FragmentManager` that will be invoked when the `FragmentTransaction` is committed and its state is not saved. The callback is defined in the `Fragment` class and is called `onStateNotSaved`. The `FragmentManager` is provided by the `Activity` that is hosting the `Fragment`. The provided code simply calls this method on the `FragmentManager`.
Summarizing entry point: void onStop()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It creates a new method called 'onStop' in the Activity class. This method is called when the Activity is stopped. It first calls the 'onStop' method in the parent class (Activity), which is used to perform any necessary cleanup. Then, it sets a flag'mStopped' to true, which is used to prevent the Activity from performing any further actions when it is stopped. Finally, it marks the Activity's Fragments as created, which ensures that they are not destroyed when the Activity is stopped.
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void startActivityForResult(android.content.Intent,int)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>
Child function not found: void clinit()
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>
Child function not found: void checkForValidRequestCode(int)
Entry point function code: void  startActivityForResult(android.content.Intent,int)  {
        if (!this.mStartedActivityFromFragment && requestCode != -1) {
            checkForValidRequestCode(requestCode);
        }
        super.startActivityForResult(intent, requestCode);
    }
Sending request to server...
Response received!
Summarized entry point function:  It appears to be a method override for the startActivityForResult method in an Activity class. The method is overridden to check for a valid request code before starting the activity. However, the provided code does not actually check for a valid request code. The code simply calls the superclass method with the provided request code without performing any checks. This could potentially cause an exception if the provided request code is invalid.
Summarizing entry point: void startActivityForResult(android.content.Intent,int,android.os.Bundle)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>
Child function not found: void clinit()
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>
Child function not found: void checkForValidRequestCode(int)
Entry point function code: void  startActivityForResult(android.content.Intent,int,android.os.Bundle)  {
        if (!this.mStartedActivityFromFragment && requestCode != -1) {
            checkForValidRequestCode(requestCode);
        }
        super.startActivityForResult(intent, requestCode);
    }
Sending request to server...
Response received!
Summarized entry point function:  It appears to be a method override for the startActivityForResult method in an Activity class. The method is overridden to check for a valid request code before starting the activity. However, the provided code does not actually check for a valid request code. The code simply calls the superclass method without performing any checks. This can potentially cause a crash if an invalid request code is provided.
Summarizing entry point: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>
Child function not found: void clinit()
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>
Child function not found: void checkForValidRequestCode(int)
Entry point function code: void  startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)  {
        if (!this.mStartedIntentSenderFromFragment && requestCode != -1) {
            checkForValidRequestCode(requestCode);
        }
        super.startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);
    }
Sending request to server...
Response received!
Summarized entry point function:  It appears to be a method that is used to start an intent sender from an activity or fragment. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.

Explanation:
1. The method'startIntentSenderForResult' is defined in the 'android.app.Activity' class.
2. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.
3. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input.
4. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.
5. The superclass method'startIntentSenderForResult' is defined in the 'android.app.Fragment' class.
6. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.
7. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input.
8. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.
Summarizing entry point: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It checks if the requestCode is a valid 16-bit unsigned integer (i.e., it is in the range 0 to 65535). If the requestCode is not valid, it throws an IllegalArgumentException with the message "Can only use lower 16 bits for requestCode".
Entry point function code: void  startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)  {
        if (!this.mStartedIntentSenderFromFragment && requestCode != -1) {
            checkForValidRequestCode(requestCode);
        }
        super.startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);
    }
Sending request to server...
Response received!
Summarized entry point function:  It's not clear from the code itself what it does. It appears to be a method that is overriding a method in the Activity class. The method is called'startIntentSenderForResult', and it takes an IntentSender, requestCode, Intent, flagsMask, flagsValues, and extraFlags as input parameters. It checks if the Activity is not started from a Fragment, and if the requestCode is not -1, it checks if the requestCode is valid using the 'checkForValidRequestCode' method. After that, it calls the'super.startIntentSenderForResult' method with the provided input parameters.
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: boolean dispatchKeyEvent(android.view.KeyEvent)
The parent function of the current child is: Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>
Child function not found: void clinit()
The parent function of the current child is: Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>
Child function not found: void clinit()
The parent function of the current child is: Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>
Child function not found: boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent)
The parent function of the current child is: Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyEvent(android.view.KeyEvent)>
Sending request to server...
Response received!
Summarized child function:  It appears to be a method that dispatches key events to a component, which is used by Android's View hierarchy. The code checks for a null component and returns false if one is found. Then, it checks the SDK version and, if it's 28 or higher, it directly calls the component's superDispatchKeyEvent method and returns its result. If the SDK version is lower than 28, it checks the type of the callback (activity or dialog) and, based on that, calls the corresponding superDispatchKeyEvent method. If the callback is null, it returns false. Finally, if the root view is not null, it calls ViewCompat.dispatchUnhandledKeyEventBeforeCallback with the root view and the event. If this returns true, it means that the event was not handled by the component and the app should continue to handle it. If it returns false, it means that the event was handled by the component and the app should not continue to handle it.
Entry point function code: boolean  dispatchKeyEvent(android.view.KeyEvent)  {
        View decor = getWindow().getDecorView();
        if (decor == null || !KeyEventDispatcher.dispatchBeforeHierarchy(decor, event)) {
            return KeyEventDispatcher.dispatchKeyEvent(this, decor, this, event);
        }
        return true;
    }
Sending request to server...
Response received!
Summarized entry point function:  It's not clear from the code itself what it does. It appears to register an event listener on the decor view of the current window, and then dispatch the event to the registered listener. However, it's not clear what the listener is doing or why it's registered on the decor view.
Summarizing entry point: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)
The parent function of the current child is: Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>
Sending request to server...
Response received!
Summarized child function:  It's not clear from the code itself what it does. It appears to be a method that dispatches an unhandled key event to the view hierarchy before the hierarchy itself handles the event. The method is called from a ViewGroup's dispatchKeyEvent method. The method returns true if the event was handled by the view hierarchy, and false otherwise.
Entry point function code: boolean  dispatchKeyShortcutEvent(android.view.KeyEvent)  {
        View decor = getWindow().getDecorView();
        if (decor == null || !KeyEventDispatcher.dispatchBeforeHierarchy(decor, event)) {
            return super.dispatchKeyShortcutEvent(event);
        }
        return true;
    }
Sending request to server...
Response received!
Summarized entry point function:  It's a method override in an Android Activity class. The method is called when the user presses a key while the activity is in focus. The method first checks if the decor view is null, which can happen if the activity is not yet fully initialized. If that's the case, the method returns false to indicate that the key shortcut event was not handled. Otherwise, it uses the KeyEventDispatcher class to dispatch the key shortcut event to the view hierarchy before the activity's own key shortcut handling. If the KeyEventDispatcher returns false, the activity's key shortcut handling will also be performed.
Not an entry point function, skipping...
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <androidx.core.app.ComponentActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It first retrieves the FragmentManager from the Activity using `activity.getFragmentManager()`. Then, it checks if there is already a fragment with the tag `REPORT_FRAGMENT_TAG`. If there is not, it adds a new `ReportFragment()` and commits the transaction using `manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit()`. Finally, it executes any pending transactions using `manager.executePendingTransactions()`.

The provided code is designed to ensure that the `ReportFragment` is only added to the Activity once, even if the Activity is recreated due to a configuration change. This is achieved by checking for the presence of the `ReportFragment` before adding it, and by using the `executePendingTransactions()` method to ensure that the FragmentTransaction is applied immediately.
Entry point function code: void  onCreate(android.os.Bundle)  {
        super.onCreate(savedInstanceState);
        ReportFragment.injectIfNeededIn(this);
    }
Sending request to server...
Response received!
Summarized entry point function:  It's not clear from the code itself what it does. It appears to register a ReportFragment for the Activity, which is needed for the Fragment to work properly.
Not an entry point function, skipping...
Summarizing entry point: void onSaveInstanceState(android.os.Bundle)
The parent function of the current child is: Entry-point: <androidx.core.app.ComponentActivity: void onSaveInstanceState(android.os.Bundle)>
Child function code is None, skipping...
Entry point function code: void  onSaveInstanceState(android.os.Bundle)  {
        this.mLifecycleRegistry.markState(Lifecycle.State.CREATED);
        super.onSaveInstanceState(outState);
    }
Sending request to server...
Response received!
Summarized entry point function:  It is used to mark the current state of the LifecycleOwner (in this case the Activity) as CREATED. This is necessary because the default state of a LifecycleOwner is DESTROYED, and the Activity will only be in the CREATED state if it is created for the first time (e.g., after a configuration change).
Summarizing entry point: void onBackPressed()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to create a new activity and override the default transition animation. The new activity is created by calling `finish()` and `overridePendingTransition(0, 0)`. The `finish()` method finishes the current activity, and the `overridePendingTransition(0, 0)` method overrides the default transition animation.
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>
Child function not found: void clinit()
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It is a Java method that sets the current message to be displayed in fullscreen mode. It first synchronizes on a mutex, then sets the message to be displayed in fullscreen mode, and finally releases the mutex.
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It first declares a MessageFullScreen object and initializes it with the value of the _messageFullScreen field. Then, it synchronizes on the _messageFullScreenMutex and copies the value of the _messageFullScreen field into the messageFullScreen object. Finally, it returns the messageFullScreen object.

The provided code is designed to provide thread safety when accessing the _messageFullScreen field. It ensures that multiple threads do not access the field simultaneously, preventing potential conflicts or race conditions when multiple threads try to modify the field.
Sending request to server...
Response received!
Summarized entry point function:  It declares a MessageFullScreen object and initializes it with the value of the _messageFullScreen field. Then, it synchronizes on the _messageFullScreenMutex and copies the value of the _messageFullScreen field into the messageFullScreen object. Finally, it returns the messageFullScreen object.
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void onResume()
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>
Sending request to server...
Response received!
Summarized child function:  It is a simple Python function that defines a message that can be used when a user tries to access a non-existent attribute of an object. The function takes a single argument (the name of the attribute that was accessed), and returns a string message indicating that the attribute does not exist.

def getMessage(attr):
    return f"The attribute '{attr}' does not exist."
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>
Sending request to server...
Response received!
Summarized child function:  It is a simple Python script that defines a function called 'run' that takes a parameter called 'None'. The function does not do anything with the provided 'None' parameter and simply returns 'None'.
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>
Sending request to server...
Response received!
Summarized child function:  It is a Java method that takes a format string and an array of arguments. It then logs the formatted string to the 'ADBMobile' log tag. The method checks if the array of arguments is null or has a length of 0, and if so, it logs the unformatted string to the 'ADBMobile' log tag.
The parent function of the current child is: Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>
Sending request to server...
Response received!
Summarized child function:  It is a Java method that takes a format string and an array of arguments. It first checks if debug logging is enabled, and if so, it logs the formatted string using the provided arguments. If debug logging is not enabled, it only logs the format string.
Sending request to server...
Response received!
Summarized entry point function:  It first initializes a 'ViewGroup' variable 'rootViewGroup' with the 'findViewById' method. It then checks if the 'rootViewGroup' variable is null, and if so, it logs an error message. If the 'rootViewGroup' variable is not null, it posts a 'Runnable' object to the 'rootViewGroup' to show the message in the root view group.
Summarizing entry point: void onSaveInstanceState(android.os.Bundle)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It saves the current message ID and replaced HTML in the instance state bundle, which can then be used to restore the message ID and replaced HTML when the activity is recreated.
Not an entry point function, skipping...
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It sets the context of the current application to 'ApplicationType.APPLICATION_TYPE_HANDHELD'. This context can be used to determine the behavior of the application in different scenarios, e.g., when it is used in a mobile app or in a desktop app.
Entry point function code: void  onCreate(android.os.Bundle)  {
        super.onCreate(savedInstanceState);
        Config.setContext(getApplicationContext());
    }
Sending request to server...
Response received!
Summarized entry point function:  It creates a new instance of the Config class and sets the context to the current application context. The Config class is a utility class that is used to store global application-wide properties.
Not an entry point function, skipping...
Summarizing entry point: void onPause()
The parent function of the current child is: Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onPause()>
Sending request to server...
Response received!
Summarized child function:  It first checks if the app is running on a wearable device, and if so, it logs a warning message. Otherwise, it stops the lifecycle data collection by calling the `stop` method on the `Lifecycle` class.
Entry point function code: void  onPause()  {
        super.onPause();
        Config.pauseCollectingLifecycleData();
    }
Sending request to server...
Response received!
Summarized entry point function:  It pauses the collection of lifecycle data in the Config class, which is used by the AppLovin SDK to track session and event data.
Not an entry point function, skipping...
Summarizing entry point: void onResume()
The parent function of the current child is: Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onResume()>
Sending request to server...
Response received!
Summarized child function:  It first checks if the app is running on a wearable device, and if not, it starts the lifecycle tracking using the `Lifecycle.start` method. The `Lifecycle.start` method is provided by the Adobe Mobile SDK, and it is used to start the lifecycle tracking for non-wearable apps. The provided code uses a `Runnable` object to execute the `Lifecycle.start` method on a separate thread, which ensures that the main thread is not blocked while the lifecycle tracking is started.
Entry point function code: void  onResume()  {
        super.onResume();
        Config.collectLifecycleData(this);
    }
Sending request to server...
Response received!
Summarized entry point function:  It collects lifecycle data by calling the Config.collectLifecycleData(this) method. The Config class is a custom class that is used to store application-wide configuration settings.
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void onActivityResult(int,int,android.content.Intent)
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>
Sending request to server...
Response received!
Summarized child function:  It declares a class called 'Zao' that extends the 'Handler' class. It then overrides the 'handleMessage' method and sends a message with ID 3 to the handler using the 'obtainMessage' method. The 'obtainMessage' method is inherited from the 'Handler' class and is used to create a new message. The message ID is used to identify the type of message that is being sent. In this case, the message is a notification message, which is used to notify the user that something has happened.
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>
Sending request to server...
Response received!
Summarized child function:  It appears to create a new instance of GoogleApiManager and call its constructor with the provided parameters. It then calls the zabr() method, which is not defined in the class.
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>
Sending request to server...
Response received!
Summarized child function:  It first initializes a `GoogleApiManager` object with the `GoogleApiAvailability` instance. Then, it checks if the `zaic` object is null, and if so, it creates a new `HandlerThread` with the name "GoogleApiHandler" and priority 9. After that, it starts the `HandlerThread`. After that, it creates a new `GoogleApiManager` object with the `context.getApplicationContext()` and the `handlerThread.getLooper()`. Finally, it returns the `GoogleApiManager` object.

The provided code is not thread-safe, because it creates a new `GoogleApiManager` object each time the method is called. To make the code thread-safe, you can use the following code:

  zab  {
        GoogleApiManager googleApiManager;
        synchronized (lock) {
            if (zaic == null) {
                HandlerThread handlerThread = new HandlerThread("GoogleApiHandler", 9);
                handlerThread.start();
                zaic = new GoogleApiManager(context.getApplicationContext(), handlerThread.getLooper(), GoogleApiAvailability.getInstance());
            }
            googleApiManager = zaic;
        }
        return googleApiManager;
    }
Sending request to server...
Response received!
Summarized entry point function:  It first checks if the request code is 1. If it is, it extracts a boolean value from the intent using the 'getBooleanExtra' method. If this value is true, it initializes a new `GoogleApiManager` object using the 'zab' function and then checks the result code. If the result code is -1, it calls the 'zao' function on the `GoogleApiManager` object to start the resolution process. If the result code is 0, it calls the 'zaa' function with a `ConnectionResult` object containing an error code of 13 and a null error message. The 'failing_client_id' extra is used to identify the ID of the client that failed to connect.
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It is a method that is used to display an error dialog in a fragment. It takes the activity that the fragment is currently attached to, an error message, and two optional listener objects. It returns true if the error dialog was shown successfully, false otherwise.
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.
The parent function of the current child is: Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It declares a Java method called 'getInstance' that returns the 'zaao' object. It is used as a singleton, which ensures that only one instance of the 'zaao' class is created.
Sending request to server...
Response received!
Summarized entry point function:  It declares two variables 'zabp' and 'pendingIntent', assigns them default values, and then checks for the presence of extras in the intent. If the extras are not present, it logs an error message and finishes the activity. If the extras are present, it checks for the'resolution' key in the bundle. If the'resolution' key is not present, it logs an error message and finishes the activity. If the'resolution' key is present, it assigns the value of'resolution' to 'zabp' and sets 'pendingIntent' to the value of the 'pending_intent' extra. It then attempts to start the activity using the 'pendingIntent' object, which will either launch the resolution activity or display the error dialog depending on the value of 'zabp'. If the activity fails to launch, it logs an error message and finishes the activity. If the activity is launched successfully, it sets 'zabp' to 1 to indicate that the error dialog was shown successfully.
Summarizing entry point: void onSaveInstanceState(android.os.Bundle)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It is saving the current value of the private variable 'zabp' (which represents the current resolution) into the 'bundle' before calling the superclass method. This is necessary because the superclass method will be called when the activity is destroyed, which will happen when the user rotates the device or navigates away from the activity. If the current resolution is not saved, the activity will be restored with the default resolution (1080x1920) which will result in a large amount of screen space being used, which is not ideal.
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>
Child function not found: int w(java.lang.String,java.lang.String)
Entry point function code: void  onCreate(android.os.Bundle)  {
        Log.w("Unity", "UnityPlayerNativeActivity has been deprecated, please update your AndroidManifest to use UnityPlayerActivity instead");
        super.onCreate(bundle);
    }
Sending request to server...
Response received!
Summarized entry point function:  It's designed to log a warning message in the Android logcat, which is a system log that can be accessed using the 'Logcat' command in the Android Debugging Tools. The message is shown when the deprecated 'UnityPlayerNativeActivity' is used in the AndroidManifest.xml. It's recommened to use the new 'UnityPlayerActivity' instead, which is a subclass of 'UnityPlayerNativeActivity' that has been updated to properly handle the transition to the new Android Activity Lifecycle.
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>
Child function not found: void clinit()
The parent function of the current child is: Entry-point: <net.gree.unitywebview.CUnityPlayerActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>
Child function not found: void clinit()
Entry point function code: void  onCreate(android.os.Bundle)  {
        requestWindowFeature(1);
        super.onCreate(bundle);
        getWindow().setFormat(2);
        this.mUnityPlayer = new CUnityPlayer(this);
        setContentView(this.mUnityPlayer);
        this.mUnityPlayer.requestFocus();
    }
Sending request to server...
Response received!
Summarized entry point function:  It appears to set the window format to RGB565, which is a 16-bit color format. However, it does not actually do this. The method `getWindow().setFormat(2);` is a no-op, and the window format will remain unchanged. The correct way to set the window format is to use `getWindow().setFormat(PixelFormat.RGB_565);`, as shown in the following code:

void  onCreate(android.os.Bundle)  {
        requestWindowFeature(1);
        super.onCreate(bundle);
        getWindow().setFormat(PixelFormat.RGB_565);
        this.mUnityPlayer = new CUnityPlayer(this);
        setContentView(this.mUnityPlayer);
        this.mUnityPlayer.requestFocus();
    }
Summarizing entry point: boolean dispatchKeyEvent(android.view.KeyEvent)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to override the dispatchKeyEvent method of the Activity class, which is called when an event is dispatched to the activity. The code checks if the key event is a key up event (ACTION_UP == 2) and, if so, it sends the event to the Unity player using the injectEvent method. If the key event is not a key up event, it is passed to the superclass (calling the original dispatchKeyEvent method) for handling.

The provided code is designed to work with the Unity player. The injectEvent method is part of the UnityPlayer class, which is a Java interface with a corresponding implementation in the UnityPlayerActivity class. The interface allows the Unity player to pass events to the activity, which handles them appropriately.
Summarizing entry point: void onConfigurationChanged(android.content.res.Configuration)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register a callback with the Android OS that is invoked when the device configuration changes. In the provided code, the callback is invoked by calling the `onConfigurationChanged` method on the `UnityPlayer` instance, which in turn calls the `configurationChanged` method on the `UnityPlayer` Java class. The `configurationChanged` method is a no-op in the base `UnityPlayer` class, but can be overridden by subclasses to provide custom behavior. In this case, the `UnityPlayer` base class is used directly, so the `configurationChanged` method is a no-op. The provided code also uses the `super` keyword, which is a reference to the parent class, in order to invoke the `onConfigurationChanged` method on the parent class. This ensures that the correct method is called for any subclasses that override the `UnityPlayer` class.
Not an entry point function, skipping...
Not an entry point function, skipping...
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It is used to request focus on the specified component, but in this case, the specified component is None, which means that the focus will be requested on the entire window.
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>
Child function code is None, skipping...
Entry point function code: void  onCreate(android.os.Bundle)  {
        requestWindowFeature(1);
        super.onCreate(bundle);
        this.mUnityPlayer = new UnityPlayer(this);
        setContentView(this.mUnityPlayer);
        this.mUnityPlayer.requestFocus();
    }
Sending request to server...
Response received!
Summarized entry point function:  It's not clear from the code itself what it does. It appears to create a new UnityPlayer instance and set it as the content view of the activity. It also requests focus for the UnityPlayer instance, which is necessary to receive input events from the Unity Player.
Summarizing entry point: void onDestroy()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It's registering an Android lifecycle callback method (onDestroy) that is called when the Activity is destroyed. In the provided code, the method is quitting the Unity player, which is necessary to properly shutdown the Unity environment. Finally, it's calling the superclass' (Activity) onDestroy method, which is necessary to ensure proper cleanup of the Activity.
Summarizing entry point: boolean onGenericMotionEvent(android.view.MotionEvent)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It's designed to forward Android touch events to the Unity player, which is running the game. The method returns true if the event was handled by the Unity player, and false otherwise.

The provided code forwards the Android MotionEvent to the Unity player by calling the 'injectEvent' method on the'mUnityPlayer' object. The 'injectEvent' method returns true if the event was handled by the player, and false otherwise.
Summarizing entry point: boolean onKeyDown(int,android.view.KeyEvent)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register an Android key event listener on the current Activity, which will then forward the key event to the Unity player when it is ready. The function returns true if the key event was handled by the Unity player, and false otherwise.
Summarizing entry point: boolean onKeyUp(int,android.view.KeyEvent)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register an Android key event listener (onKeyUp) that forwards the key event to the Unity player. The function returns true if the event was handled by the Unity player, otherwise false.

The provided code is part of a class that extends the UnityPlayerActivity. The class overrides the onKeyUp function to forward key events to the Unity player.
Summarizing entry point: void onLowMemory()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register an Android activity callback that is called when the app is running low on memory. It then calls the `lowMemory` method on the Unity player object, which is used to free unused resources.
Summarizing entry point: void onNewIntent(android.content.Intent)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It appears to register an activity lifecycle callback that sets the current activity's intent to the provided intent. The callback is called when the activity is created from a new intent, e.g., when the user clicks on an app icon in the launcher. The provided code is not actually functional and will not affect the behavior of the app.
Summarizing entry point: void onPause()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It pauses the Unity player when the app is paused.
Summarizing entry point: void onResume()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It is registering an activity lifecycle callback method (onResume) that will be invoked when the activity is resumed. In the callback method, it is calling the UnityPlayer (mUnityPlayer) resume method, which will cause the Unity content to be rendered.
Summarizing entry point: void onStart()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It starts a new activity in the AndroidManifest.xml file and then initializes the Unity player. The onStart() method is a lifecycle callback that is called when the activity is created. In this case, it is used to start the Unity player.
Summarizing entry point: void onStop()
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It is designed to override the `onStop()` method of the `Activity` class, which is called when the activity is about to stop. In this case, it is used to stop the Unity player, which is running in the background.
Summarizing entry point: boolean onTouchEvent(android.view.MotionEvent)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It's designed to forward touch events to the Unity player, which is running the game. The code declares a boolean function 'onTouchEvent' that takes a 'MotionEvent' as an input. It then returns the result of calling the 'injectEvent' function on the Unity player instance, which is provided as a member variable. This means that the function will return true if the event was successfully injected, and false otherwise.
Summarizing entry point: void onTrimMemory(int)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It's registering an `onTrimMemory` callback with the Android Activity Manager. The callback is invoked when the system needs to free up memory. The provided code is checking for the `TRIM_MEMORY_RUNNING_LOW` constant, which is used to indicate that the system is running low on memory. If the callback is invoked with this constant, it's instructing the `UnityPlayer` to release unused memory.
Summarizing entry point: void onWindowFocusChanged(boolean)
No children functions for this entry point
Sending request to server...
Response received!
Summarized entry point function:  It's registering an override for the `onWindowFocusChanged` method in the `UnityPlayerActivity` class. The override is calling the superclass implementation of the method and then forwarding the call to the `UnityPlayer` instance, which is used to interact with the Unity Engine. The `windowFocusChanged` method is a part of the `UnityPlayer` class and is used to notify the Unity Engine about the change in the window focus.
Summarizing entry point: void onCreate(android.os.Bundle)
The parent function of the current child is: Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>
Sending request to server...
Response received!
Summarized child function:  It declares a variable 'w' and assigns it the value 'None'. Then, it prints the value of 'w' to the console, which will be 'None'.
Entry point function code: void  onCreate(android.os.Bundle)  {
        Log.w("Unity", "UnityPlayerProxyActivity has been deprecated, please update your AndroidManifest to use UnityPlayerActivity instead");
        super.onCreate(bundle);
    }
Sending request to server...
Response received!
Summarized entry point function:  It's designed to log a warning message in the Android logcat, which is a system log that can be accessed using 'adb logcat' command. The message is displayed only once, so it will not be repeated if the app is restarted. The code uses the 'Log.w' method, which is a static method in the 'Log' class. The first parameter is the tag, which is used to identify the source of the message. In this case, the tag is 'Unity'. The second parameter is the message itself.

The provided code is designed to support the old 'UnityPlayerProxyActivity' class, which has been deprecated in favor of the new 'UnityPlayerActivity' class. The new class is more efficient and does not require any additional permissions, so it's recommended to use it instead of the old one. The updated code should look like this:

void  onCreate(android.os.Bundle)  {
        Log.w("Unity", "The 'UnityPlayerProxyActivity' class has been deprecated, please update your AndroidManifest to use the 'UnityPlayerActivity' class instead.");
        super.onCreate(bundle);
    }
Parsing complete!

Results: {'Entry-point: <androidx.fragment.app.FragmentActivity: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])>': {'entry_point name': 'void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])', 'code': 'void  dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])  {\n        super.dump(prefix, fd, writer, args);\n        writer.print(prefix);\n        writer.print("Local FragmentActivity ");\n        writer.print(Integer.toHexString(System.identityHashCode(this)));\n        writer.println(" State:");\n        String innerPrefix = prefix + "  ";\n        writer.print(innerPrefix);\n        writer.print("mCreated=");\n        writer.print(this.mCreated);\n        writer.print(" mResumed=");\n        writer.print(this.mResumed);\n        writer.print(" mStopped=");\n        writer.print(this.mStopped);\n        if (getApplication() != null) {\n            LoaderManager.getInstance(this).dump(innerPrefix, fd, writer, args);\n        }\n        this.mFragments.getSupportFragmentManager().dump(prefix, fd, writer, args);\n    }', 'summary': " It first prints a prefix, then it prints the value of the'mId' field, then it prints the value of the'mArgs' field, then it prints the loader, and finally it dumps the loader's data. The provided code is designed to provide a concise and readable representation of the Loader's internal state.  It calculates the hash code of the object 'None' using the 'identityHashCode' method, which returns the same hash code for every 'None' instance.  It converts a number to a hexadecimal string representation. However, it does not provide any input validation, so it's possible to generate an invalid hexadecimal string if the input is not a number. For example, calling `toHexString(NaN)` will generate the string 'NaN', which is not a valid hexadecimal string.  It declares a method called 'getInstance' that returns a new instance of the 'LoaderManagerImpl' class. It takes two arguments: 'owner' and'store'. The 'owner' argument is a reference to the object that owns the new instance, and the'store' argument is a reference to the View Model Store that the owner will use to store its View Models. The method first creates a new instance of the 'LoaderManagerImpl' class, and then initializes it with the provided 'owner' and'store' arguments. Finally, it returns the new instance.", 'children': {'void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])': " It first prints a prefix, then it prints the value of the'mId' field, then it prints the value of the'mArgs' field, then it prints the loader, and finally it dumps the loader's data. The provided code is designed to provide a concise and readable representation of the Loader's internal state.", 'int identityHashCode(java.lang.Object)': " It calculates the hash code of the object 'None' using the 'identityHashCode' method, which returns the same hash code for every 'None' instance.", 'java.lang.String toHexString(int)': " It converts a number to a hexadecimal string representation. However, it does not provide any input validation, so it's possible to generate an invalid hexadecimal string if the input is not a number. For example, calling `toHexString(NaN)` will generate the string 'NaN', which is not a valid hexadecimal string.", 'androidx.loader.app.LoaderManager getInstance(androidx.lifecycle.LifecycleOwner)': " It declares a method called 'getInstance' that returns a new instance of the 'LoaderManagerImpl' class. It takes two arguments: 'owner' and'store'. The 'owner' argument is a reference to the object that owns the new instance, and the'store' argument is a reference to the View Model Store that the owner will use to store its View Models. The method first creates a new instance of the 'LoaderManagerImpl' class, and then initializes it with the provided 'owner' and'store' arguments. Finally, it returns the new instance."}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onActivityResult(int,int,android.content.Intent)>': {'entry_point name': 'void onActivityResult(int,int,android.content.Intent)', 'code': 'void  onActivityResult(int,int,android.content.Intent)  {\n        this.mFragments.noteStateNotSaved();\n        int requestIndex = requestCode >> 16;\n        if (requestIndex != 0) {\n            int requestIndex2 = requestIndex - 1;\n            String who = this.mPendingFragmentActivityResults.get(requestIndex2);\n            this.mPendingFragmentActivityResults.remove(requestIndex2);\n            if (who == null) {\n                Log.w(TAG, "Activity result delivered for unknown Fragment.");\n                return;\n            }\n            Fragment targetFragment = this.mFragments.findFragmentByWho(who);\n            if (targetFragment == null) {\n                Log.w(TAG, "Activity result no fragment exists for who: " + who);\n                return;\n            } else {\n                targetFragment.onActivityResult(65535 & requestCode, resultCode, data);\n                return;\n            }\n        }\n        ActivityCompat.PermissionCompatDelegate delegate = ActivityCompat.getPermissionCompatDelegate();\n        if (delegate == null || !delegate.onActivityResult(this, requestCode, resultCode, data)) {\n            super.onActivityResult(requestCode, resultCode, data);\n        }\n    }', 'summary': " It appears to handle activity results for Fragments, but it's not clear what it actually does. The code checks for a request code greater than 65535, which is the maximum value for a 16-bit integer. If this is true, it means the code is handling a result for a Fragment, so it divides the request code by 65536 and uses the remainder as an index into an array of pending Fragment activity results. If the index is 0, it means the activity result is not for a Fragment, so it calls the superclass method. If the index is not 0, it retrieves the name of the Fragment that the activity result is for and uses it to find the target Fragment in the Fragment manager. If the target Fragment is found, it calls the target Fragment's `onActivityResult` method with the lower 16 bits of the request code and the other parameters. If the target Fragment is not found, it logs a warning.", 'children': {'androidx.core.app.ActivityCompat$PermissionCompatDelegate getPermissionCompatDelegate()': " It declares a method called 'getPermissionCompatDelegate' that returns the static'sDelegate' field. It is used to provide backwards compatibility with older versions of the Android permission API.", 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onBackPressed()>': {'entry_point name': 'void onBackPressed()', 'code': 'void  onBackPressed()  {\n        FragmentManager fragmentManager = this.mFragments.getSupportFragmentManager();\n        boolean isStateSaved = fragmentManager.isStateSaved();\n        if (!isStateSaved || Build.VERSION.SDK_INT > 25) {\n            if (isStateSaved || !fragmentManager.popBackStackImmediate()) {\n                super.onBackPressed();\n            }\n        }\n    }', 'summary': ' It first checks if the fragment manager is in a saved state, and if not, it pops the back stack. However, it only does this if the SDK version is below 26. If the SDK version is 26 or higher, it will always pop the back stack, even if it is in a saved state. This is because the new FragmentManager.popBackStackImmediate() method restores the state of the manager if it is saved, and the old method does not.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onConfigurationChanged(android.content.res.Configuration)>': {'entry_point name': 'void onConfigurationChanged(android.content.res.Configuration)', 'code': 'void  onConfigurationChanged(android.content.res.Configuration)  {\n        super.onConfigurationChanged(newConfig);\n        this.mFragments.noteStateNotSaved();\n        this.mFragments.dispatchConfigurationChanged(newConfig);\n    }', 'summary': ' It appears to register a listener for configuration changes and then call the `dispatchConfigurationChanged` method on the `FragmentManager`. However, it does not provide any explanation as to why this is necessary or what it achieves.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        this.mFragments.attachHost(null);\n        super.onCreate(savedInstanceState);\n        NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance();\n        if (nc != null && nc.viewModelStore != null && this.mViewModelStore == null) {\n            this.mViewModelStore = nc.viewModelStore;\n        }\n        if (savedInstanceState != null) {\n            Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);\n            this.mFragments.restoreAllState(p, nc != null ? nc.fragments : null);\n            if (savedInstanceState.containsKey(NEXT_CANDIDATE_REQUEST_INDEX_TAG)) {\n                this.mNextCandidateRequestIndex = savedInstanceState.getInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG);\n                int[] requestCodes = savedInstanceState.getIntArray(ALLOCATED_REQUEST_INDICIES_TAG);\n                String[] fragmentWhos = savedInstanceState.getStringArray(REQUEST_FRAGMENT_WHO_TAG);\n                if (requestCodes == null || fragmentWhos == null || requestCodes.length != fragmentWhos.length) {\n                    Log.w(TAG, "Invalid requestCode mapping in savedInstanceState.");\n                } else {\n                    this.mPendingFragmentActivityResults = new SparseArrayCompat<>(requestCodes.length);\n                    for (int i = 0; i < requestCodes.length; i++) {\n                        this.mPendingFragmentActivityResults.put(requestCodes[i], fragmentWhos[i]);\n                    }\n                }\n            }\n        }\n        if (this.mPendingFragmentActivityResults == null) {\n            this.mPendingFragmentActivityResults = new SparseArrayCompat<>();\n            this.mNextCandidateRequestIndex = 0;\n        }\n        this.mFragments.dispatchCreate();\n    }', 'summary': " It first initializes a `NonConfigurationInstances` object with the last non-configuration instance (if any) and then checks if the `NonConfigurationInstances` object has a `viewModelStore` field set. If this is the case, it assigns the `viewModelStore` field of the `NonConfigurationInstances` object to the `mViewModelStore` field of the `FragmentActivity` instance. Next, it checks if there is a saved instance state in the provided `savedInstanceState` parameter. If this is the case, it restores the activity's fragments from the saved state and assigns the saved `nextCandidateRequestIndex` value to the `mNextCandidateRequestIndex` field. If there is an invalid request code mapping in the saved instance state, a `Log.w` message is printed. Finally, it initializes a `SparseArrayCompat` for pending fragment activity results and assigns it to the `mPendingFragmentActivityResults` field.", 'children': {'void put(int,java.lang.Object)': ' It first initializes two arrays, mKeys and mValues, with the size of the expected storage (mSize). Then it searches for the position of the given key in the array using the binarySearch method. If the key is found, it updates the value at that position. If the key is not found, it searches for a position where the key can be inserted without violating the ordering. If there is an empty position, it inserts the key-value pair there. If there is no empty position, it doubles the size of the arrays and inserts the key-value pair at the new position.', 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: boolean onCreatePanelMenu(int,android.view.Menu)>': {'entry_point name': 'boolean onCreatePanelMenu(int,android.view.Menu)', 'code': 'boolean  onCreatePanelMenu(int,android.view.Menu)  {\n        if (featureId == 0) {\n            boolean show = super.onCreatePanelMenu(featureId, menu);\n            return show | this.mFragments.dispatchCreateOptionsMenu(menu, getMenuInflater());\n        }\n        boolean show2 = super.onCreatePanelMenu(featureId, menu);\n        return show2;\n    }', 'summary': ' It appears to create a menu item for the activity, and then dispatch the creation of the menu items to the fragments attached to the activity. The question is: why is the code dispatching the menu creation to the fragments when the activity is already creating the menu?', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onDestroy()>': {'entry_point name': 'void onDestroy()', 'code': 'void  onDestroy()  {\n        super.onDestroy();\n        if (this.mViewModelStore != null && !isChangingConfigurations()) {\n            this.mViewModelStore.clear();\n        }\n        this.mFragments.dispatchDestroy();\n    }', 'summary': " It first initializes a ViewModelStore instance (this.mViewModelStore) and then checks if the Activity is not in the process of being re-created (isChangingConfigurations()). If the Activity is not being re-created, it clears the ViewModelStore instance (this.mViewModelStore.clear()). Finally, it dispatches the Activity's onDestroy() to its fragments (this.mFragments.dispatchDestroy()).", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onLowMemory()>': {'entry_point name': 'void onLowMemory()', 'code': 'void  onLowMemory()  {\n        super.onLowMemory();\n        this.mFragments.dispatchLowMemory();\n    }', 'summary': " It's registering an `onLowMemory` callback with the Activity's FragmentManager. The callback is then invoked when the Activity's memory is low, which is detected by the Android system. The callback is then delegating the call to the Activity's base class, which in turn calls the `onLowMemory` method on the Activity. The `onLowMemory` method in the Activity is then responsible for freeing any memory that it's holding.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: boolean onMenuItemSelected(int,android.view.MenuItem)>': {'entry_point name': 'boolean onMenuItemSelected(int,android.view.MenuItem)', 'code': 'boolean  onMenuItemSelected(int,android.view.MenuItem)  {\n        if (super.onMenuItemSelected(featureId, item)) {\n            return true;\n        }\n        switch (featureId) {\n            case 0:\n                return this.mFragments.dispatchOptionsItemSelected(item);\n            case 6:\n                return this.mFragments.dispatchContextItemSelected(item);\n            default:\n                return false;\n        }\n    }', 'summary': ' It appears to be a method that is called when a menu item is selected. It first checks if the item was handled by the superclass (this will be true for items in the main menu, such as "Save" or "Share"), and if not, it checks if the item is part of a fragment container (0 or 6). If so, it dispatches the item to the appropriate fragment container. If not, it returns false, indicating that the item was not handled.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onMultiWindowModeChanged(boolean)>': {'entry_point name': 'void onMultiWindowModeChanged(boolean)', 'code': 'void  onMultiWindowModeChanged(boolean)  {\n        this.mFragments.dispatchMultiWindowModeChanged(isInMultiWindowMode);\n    }', 'summary': " It's registering a callback with the Activity's FragmentManager, which will be invoked when the multi-window mode changes. The callback is provided with a boolean parameter indicating the new multi-window mode. The callback is then dispatching the mode change to all registered Fragments using the FragmentManager's `dispatchMultiWindowModeChanged` method.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onNewIntent(android.content.Intent)>': {'entry_point name': 'void onNewIntent(android.content.Intent)', 'code': 'void  onNewIntent(android.content.Intent)  {\n        super.onNewIntent(intent);\n        this.mFragments.noteStateNotSaved();\n    }', 'summary': " It appears to register an activity lifecycle callback that is used to notify the FragmentManager that the activity state has changed and not all fragments have been saved. The callback is invoked in the superclass, which in this case is Activity. In the provided code, the callback is overridden and the FragmentManager's state is explicitly saved.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onPanelClosed(int,android.view.Menu)>': {'entry_point name': 'void onPanelClosed(int,android.view.Menu)', 'code': 'void  onPanelClosed(int,android.view.Menu)  {\n        switch (featureId) {\n            case 0:\n                this.mFragments.dispatchOptionsMenuClosed(menu);\n                break;\n        }\n        super.onPanelClosed(featureId, menu);\n    }', 'summary': " It appears to register an `onPanelClosed` callback for a specific feature ID (0). When the panel with the given feature ID is closed, the provided code dispatches the `OptionsMenu` to all registered fragments and then calls the superclass' `onPanelClosed` method. The superclass' `onPanelClosed` method is empty, so it does not actually do anything. The provided code is designed to be overridden by subclasses, so it is important to analyze it correctly.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onPause()>': {'entry_point name': 'void onPause()', 'code': 'void  onPause()  {\n        super.onPause();\n        this.mResumed = false;\n        if (this.mHandler.hasMessages(2)) {\n            this.mHandler.removeMessages(2);\n            onResumeFragments();\n        }\n        this.mFragments.dispatchPause();\n    }', 'summary': ' It appears to override the `onPause` method of the Activity, which is used to pause the activity when the user switches to another application or to the home screen. The code checks if there are any pending messages with the ID 2 (which is used to indicate that the activity has been paused due to a configuration change), and if there are, it removes them and calls the `onResumeFragments` method, which is used to re-start any fragments that were stopped due to the configuration change. Finally, it dispatches the `onPause` event to all fragments in the activity.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onPictureInPictureModeChanged(boolean)>': {'entry_point name': 'void onPictureInPictureModeChanged(boolean)', 'code': 'void  onPictureInPictureModeChanged(boolean)  {\n        this.mFragments.dispatchPictureInPictureModeChanged(isInPictureInPictureMode);\n    }', 'summary': " It's designed to dispatch a callback to the Activity or Fragment that's currently in picture-in-picture mode, which is then responsible for reacting to the change. The provided code is a no-op, which will do nothing when the callback is dispatched.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onPostResume()>': {'entry_point name': 'void onPostResume()', 'code': 'void  onPostResume()  {\n        super.onPostResume();\n        this.mHandler.removeMessages(2);\n        onResumeFragments();\n        this.mFragments.execPendingActions();\n    }', 'summary': ' It appears to register a `onPostResume` callback with the Activity, which is then called when the Activity is resumed after being paused. The code then removes any pending messages with ID 2 from the handler, which are used to indicate that the Activity is in the background. After that, it calls the `onResumeFragments` method, which is supposed to handle any pending Fragment transactions. Finally, it executes any pending actions on the Fragment Manager, which are used to update the UI after a configuration change.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: boolean onPreparePanel(int,android.view.View,android.view.Menu)>': {'entry_point name': 'boolean onPreparePanel(int,android.view.View,android.view.Menu)', 'code': 'boolean  onPreparePanel(int,android.view.View,android.view.Menu)  {\n        if (featureId == 0 && menu != null) {\n            boolean goforit = onPrepareOptionsPanel(view, menu);\n            return goforit | this.mFragments.dispatchPrepareOptionsMenu(menu);\n        }\n        boolean goforit2 = super.onPreparePanel(featureId, view, menu);\n        return goforit2;\n    }', 'summary': " It appears to be a method override in an Activity class. The method is called when the Activity is ready to show a context menu for a particular view (typically a ViewPager). The method first checks if the provided feature ID is 0, indicating that the context menu is being shown for the ViewPager. If this is true, it then checks if the provided menu is not null. If this is true, it then calls the method onPrepareOptionsPanel() and stores the result in a boolean variable 'goforit'. It then dispatches the menu preparation to the child Fragments using the FragmentManager, and stores the result in a second boolean variable 'goforit2'. The final result is the OR of the two boolean variables, which is then returned.\n\nThe provided code is designed to ensure that the child Fragments receive the menu preparation, even if the Activity's onPreparePanel() method returns false. This is necessary because the ViewPager does not call onPreparePanel() on its own, and therefore the child Fragments do not receive the menu preparation.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onRequestPermissionsResult(int,java.lang.String[],int[])>': {'entry_point name': 'void onRequestPermissionsResult(int,java.lang.String[],int[])', 'code': 'void  onRequestPermissionsResult(int,java.lang.String[],int[])  {\n        this.mFragments.noteStateNotSaved();\n        int index = (requestCode >> 16) & SupportMenu.USER_MASK;\n        if (index != 0) {\n            int index2 = index - 1;\n            String who = this.mPendingFragmentActivityResults.get(index2);\n            this.mPendingFragmentActivityResults.remove(index2);\n            if (who == null) {\n                Log.w(TAG, "Activity result delivered for unknown Fragment.");\n                return;\n            }\n            Fragment frag = this.mFragments.findFragmentByWho(who);\n            if (frag == null) {\n                Log.w(TAG, "Activity result no fragment exists for who: " + who);\n            } else {\n                frag.onRequestPermissionsResult(requestCode & SupportMenu.USER_MASK, permissions, grantResults);\n            }\n        }\n    }', 'summary': " It is converting the value of 'None' to a string 'None'. This is useful when you want to print the value of an optional variable without having to check if it is not None beforehand.  It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list.", 'children': {'java.lang.String toString()': " It converts the value of 'None' to a string 'None'. This is useful when you want to print the value of an optional variable without having to check if it is not None beforehand.", 'java.lang.StringBuilder append(java.lang.String)': " It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list."}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onResume()>': {'entry_point name': 'void onResume()', 'code': 'void  onResume()  {\n        super.onResume();\n        this.mHandler.sendEmptyMessage(2);\n        this.mResumed = true;\n        this.mFragments.execPendingActions();\n    }', 'summary': " It appears to register a new message (with ID 2) on the main thread's message queue, which will then be processed in the `handleMessage` method of the `FragmentActivity` class. The `onResume` method is called when the activity is resumed, which is typically when the user switches back to the app after it has been put in the background. The code then sets a flag indicating that the activity has been resumed, and finally calls the `execPendingActions` method of the `FragmentManager` to execute any pending actions that were added to the queue while the activity was paused.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onSaveInstanceState(android.os.Bundle)>': {'entry_point name': 'void onSaveInstanceState(android.os.Bundle)', 'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        super.onSaveInstanceState(outState);\n        markFragmentsCreated();\n        Parcelable p = this.mFragments.saveAllState();\n        if (p != null) {\n            outState.putParcelable(FRAGMENTS_TAG, p);\n        }\n        if (this.mPendingFragmentActivityResults.size() > 0) {\n            outState.putInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG, this.mNextCandidateRequestIndex);\n            int[] requestCodes = new int[this.mPendingFragmentActivityResults.size()];\n            String[] fragmentWhos = new String[this.mPendingFragmentActivityResults.size()];\n            for (int i = 0; i < this.mPendingFragmentActivityResults.size(); i++) {\n                requestCodes[i] = this.mPendingFragmentActivityResults.keyAt(i);\n                fragmentWhos[i] = this.mPendingFragmentActivityResults.valueAt(i);\n            }\n            outState.putIntArray(ALLOCATED_REQUEST_INDICIES_TAG, requestCodes);\n            outState.putStringArray(REQUEST_FRAGMENT_WHO_TAG, fragmentWhos);\n        }\n    }', 'summary': " It first calls the superclass' `onSaveInstanceState()` method with the provided `Bundle` object, then it marks the fragments as created, and finally it saves the fragment states in a `Parcelable` object. If there are any pending fragment activity results, it adds the request indices, request codes, and fragment owners to the `Bundle`.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onStart()>': {'entry_point name': 'void onStart()', 'code': 'void  onStart()  {\n        super.onStart();\n        this.mStopped = false;\n        if (!this.mCreated) {\n            this.mCreated = true;\n            this.mFragments.dispatchActivityCreated();\n        }\n        this.mFragments.noteStateNotSaved();\n        this.mFragments.execPendingActions();\n        this.mFragments.dispatchStart();\n    }', 'summary': " It creates a new activity and starts it. It first calls the `super.onStart()` method, which is then followed by some code that initializes the activity's state and starts the fragments in the activity. The `super.onStart()` method is necessary in every Activity, and it initializes the activity's state. In this case, it initializes the `mStopped` field to `false`. The `mCreated` field is also initialized to `true`, indicating that the activity has been created. The `mFragments.dispatchActivityCreated()` method is then called, which in turn calls the `onActivityCreated()` method in all fragments attached to the activity. The `mFragments.noteStateNotSaved()` method is called to indicate that the activity's state has not been saved. The `mFragments.execPendingActions()` method is then called, which ensures that any pending actions, such as `onAttach()` or `onCreateView()` have been executed. Finally, the `mFragments.dispatchStart()` method is called, which in turn calls the `onStart()` method in all fragments attached to the activity.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onStateNotSaved()>': {'entry_point name': 'void onStateNotSaved()', 'code': 'void  onStateNotSaved()  {\n        this.mFragments.noteStateNotSaved();\n    }', 'summary': ' It appears to register a callback with the `FragmentManager` that will be invoked when the `FragmentTransaction` is committed and its state is not saved. The callback is defined in the `Fragment` class and is called `onStateNotSaved`. The `FragmentManager` is provided by the `Activity` that is hosting the `Fragment`. The provided code simply calls this method on the `FragmentManager`.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void onStop()>': {'entry_point name': 'void onStop()', 'code': 'void  onStop()  {\n        super.onStop();\n        this.mStopped = true;\n        markFragmentsCreated();\n        this.mFragments.dispatchStop();\n    }', 'summary': " It creates a new method called 'onStop' in the Activity class. This method is called when the Activity is stopped. It first calls the 'onStop' method in the parent class (Activity), which is used to perform any necessary cleanup. Then, it sets a flag'mStopped' to true, which is used to prevent the Activity from performing any further actions when it is stopped. Finally, it marks the Activity's Fragments as created, which ensures that they are not destroyed when the Activity is stopped.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void startActivityForResult(android.content.Intent,int)>': {'entry_point name': 'void startActivityForResult(android.content.Intent,int)', 'code': 'void  startActivityForResult(android.content.Intent,int)  {\n        if (!this.mStartedActivityFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startActivityForResult(intent, requestCode);\n    }', 'summary': ' It appears to be a method override for the startActivityForResult method in an Activity class. The method is overridden to check for a valid request code before starting the activity. However, the provided code does not actually check for a valid request code. The code simply calls the superclass method with the provided request code without performing any checks. This could potentially cause an exception if the provided request code is invalid.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void startActivityForResult(android.content.Intent,int,android.os.Bundle)>': {'entry_point name': 'void startActivityForResult(android.content.Intent,int,android.os.Bundle)', 'code': 'void  startActivityForResult(android.content.Intent,int,android.os.Bundle)  {\n        if (!this.mStartedActivityFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startActivityForResult(intent, requestCode);\n    }', 'summary': ' It appears to be a method override for the startActivityForResult method in an Activity class. The method is overridden to check for a valid request code before starting the activity. However, the provided code does not actually check for a valid request code. The code simply calls the superclass method without performing any checks. This can potentially cause a crash if an invalid request code is provided.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)>': {'entry_point name': 'void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)', 'code': 'void  startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)  {\n        if (!this.mStartedIntentSenderFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);\n    }', 'summary': " It appears to be a method that is used to start an intent sender from an activity or fragment. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.\n\nExplanation:\n1. The method'startIntentSenderForResult' is defined in the 'android.app.Activity' class.\n2. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.\n3. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input.\n4. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.\n5. The superclass method'startIntentSenderForResult' is defined in the 'android.app.Fragment' class.\n6. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.\n7. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input.\n8. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.fragment.app.FragmentActivity: void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)>': {'entry_point name': 'void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)', 'code': 'void  startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)  {\n        if (!this.mStartedIntentSenderFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);\n    }', 'summary': " It's not clear from the code itself what it does. It appears to be a method that is overriding a method in the Activity class. The method is called'startIntentSenderForResult', and it takes an IntentSender, requestCode, Intent, flagsMask, flagsValues, and extraFlags as input parameters. It checks if the Activity is not started from a Fragment, and if the requestCode is not -1, it checks if the requestCode is valid using the 'checkForValidRequestCode' method. After that, it calls the'super.startIntentSenderForResult' method with the provided input parameters.", 'children': {'void checkForValidRequestCode(int)': ' It checks if the requestCode is a valid 16-bit unsigned integer (i.e., it is in the range 0 to 65535). If the requestCode is not valid, it throws an IllegalArgumentException with the message "Can only use lower 16 bits for requestCode".', 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyEvent(android.view.KeyEvent)>': {'entry_point name': 'boolean dispatchKeyEvent(android.view.KeyEvent)', 'code': 'boolean  dispatchKeyEvent(android.view.KeyEvent)  {\n        View decor = getWindow().getDecorView();\n        if (decor == null || !KeyEventDispatcher.dispatchBeforeHierarchy(decor, event)) {\n            return KeyEventDispatcher.dispatchKeyEvent(this, decor, this, event);\n        }\n        return true;\n    }', 'summary': " It's not clear from the code itself what it does. It appears to register an event listener on the decor view of the current window, and then dispatch the event to the registered listener. However, it's not clear what the listener is doing or why it's registered on the decor view.", 'children': {'boolean dispatchKeyEvent(androidx.core.view.KeyEventDispatcher$Component,android.view.View,android.view.Window$Callback,android.view.KeyEvent)': " It appears to be a method that dispatches key events to a component, which is used by Android's View hierarchy. The code checks for a null component and returns false if one is found. Then, it checks the SDK version and, if it's 28 or higher, it directly calls the component's superDispatchKeyEvent method and returns its result. If the SDK version is lower than 28, it checks the type of the callback (activity or dialog) and, based on that, calls the corresponding superDispatchKeyEvent method. If the callback is null, it returns false. Finally, if the root view is not null, it calls ViewCompat.dispatchUnhandledKeyEventBeforeCallback with the root view and the event. If this returns true, it means that the event was not handled by the component and the app should continue to handle it. If it returns false, it means that the event was handled by the component and the app should not continue to handle it.", 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.core.app.ComponentActivity: boolean dispatchKeyShortcutEvent(android.view.KeyEvent)>': {'entry_point name': 'boolean dispatchKeyShortcutEvent(android.view.KeyEvent)', 'code': 'boolean  dispatchKeyShortcutEvent(android.view.KeyEvent)  {\n        View decor = getWindow().getDecorView();\n        if (decor == null || !KeyEventDispatcher.dispatchBeforeHierarchy(decor, event)) {\n            return super.dispatchKeyShortcutEvent(event);\n        }\n        return true;\n    }', 'summary': " It's a method override in an Android Activity class. The method is called when the user presses a key while the activity is in focus. The method first checks if the decor view is null, which can happen if the activity is not yet fully initialized. If that's the case, the method returns false to indicate that the key shortcut event was not handled. Otherwise, it uses the KeyEventDispatcher class to dispatch the key shortcut event to the view hierarchy before the activity's own key shortcut handling. If the KeyEventDispatcher returns false, the activity's key shortcut handling will also be performed.", 'children': {'boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent)': " It's not clear from the code itself what it does. It appears to be a method that dispatches an unhandled key event to the view hierarchy before the hierarchy itself handles the event. The method is called from a ViewGroup's dispatchKeyEvent method. The method returns true if the event was handled by the view hierarchy, and false otherwise.", 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.core.app.ComponentActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n    }', 'summary': " It's not clear from the code itself what it does. It appears to register a ReportFragment for the Activity, which is needed for the Fragment to work properly.", 'children': {'void injectIfNeededIn(android.app.Activity)': ' It first retrieves the FragmentManager from the Activity using `activity.getFragmentManager()`. Then, it checks if there is already a fragment with the tag `REPORT_FRAGMENT_TAG`. If there is not, it adds a new `ReportFragment()` and commits the transaction using `manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit()`. Finally, it executes any pending transactions using `manager.executePendingTransactions()`.\n\nThe provided code is designed to ensure that the `ReportFragment` is only added to the Activity once, even if the Activity is recreated due to a configuration change. This is achieved by checking for the presence of the `ReportFragment` before adding it, and by using the `executePendingTransactions()` method to ensure that the FragmentTransaction is applied immediately.', 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <androidx.core.app.ComponentActivity: void onSaveInstanceState(android.os.Bundle)>': {'entry_point name': 'void onSaveInstanceState(android.os.Bundle)', 'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        this.mLifecycleRegistry.markState(Lifecycle.State.CREATED);\n        super.onSaveInstanceState(outState);\n    }', 'summary': ' It is used to mark the current state of the LifecycleOwner (in this case the Activity) as CREATED. This is necessary because the default state of a LifecycleOwner is DESTROYED, and the Activity will only be in the CREATED state if it is created for the first time (e.g., after a configuration change).', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onBackPressed()>': {'entry_point name': 'void onBackPressed()', 'code': 'void  onBackPressed()  {\n        if (this.message != null) {\n            this.message.isVisible = false;\n            this.message.viewed();\n        }\n        finish();\n        overridePendingTransition(0, 0);\n    }', 'summary': ' It appears to create a new activity and override the default transition animation. The new activity is created by calling `finish()` and `overridePendingTransition(0, 0)`. The `finish()` method finishes the current activity, and the `overridePendingTransition(0, 0)` method overrides the default transition animation.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState != null) {\n            this.message = restoreFromSavedState(savedInstanceState);\n            Messages.setCurrentMessageFullscreen(this.message);\n        } else {\n            this.message = Messages.getCurrentFullscreenMessage();\n        }\n        if (messageIsValid()) {\n            this.message.messageFullScreenActivity = this;\n            requestWindowFeature(1);\n            RelativeLayout relativeLayout = new RelativeLayout(this);\n            setContentView(relativeLayout);\n        }\n    }', 'summary': ' It declares a MessageFullScreen object and initializes it with the value of the _messageFullScreen field. Then, it synchronizes on the _messageFullScreenMutex and copies the value of the _messageFullScreen field into the messageFullScreen object. Finally, it returns the messageFullScreen object.', 'children': {'void setCurrentMessageFullscreen(com.adobe.mobile.MessageFullScreen)': ' It is a Java method that sets the current message to be displayed in fullscreen mode. It first synchronizes on a mutex, then sets the message to be displayed in fullscreen mode, and finally releases the mutex.', 'com.adobe.mobile.MessageFullScreen getCurrentFullscreenMessage()': ' It first declares a MessageFullScreen object and initializes it with the value of the _messageFullScreen field. Then, it synchronizes on the _messageFullScreenMutex and copies the value of the _messageFullScreen field into the messageFullScreen object. Finally, it returns the messageFullScreen object.\n\nThe provided code is designed to provide thread safety when accessing the _messageFullScreen field. It ensures that multiple threads do not access the field simultaneously, preventing potential conflicts or race conditions when multiple threads try to modify the field.'}}, 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onResume()>': {'entry_point name': 'void onResume()', 'code': 'void  onResume()  {\n        super.onResume();\n        if (messageIsValid()) {\n            try {\n                final ViewGroup rootViewGroup = (ViewGroup) findViewById(16908290);\n                if (rootViewGroup == null) {\n                    StaticMethods.logErrorFormat("Messages - unable to get root view group from os", new Object[0]);\n                    finish();\n                    overridePendingTransition(0, 0);\n                } else {\n                    rootViewGroup.post(new Runnable() { // from class: com.adobe.mobile.MessageFullScreenActivity.1\n                        @Override // java.lang.Runnable\n                        public void run() {\n                            MessageFullScreenActivity.this.message.rootViewGroup = rootViewGroup;\n                            MessageFullScreenActivity.this.message.showInRootViewGroup();\n                        }\n                    });\n                }\n            } catch (NullPointerException ex) {\n                StaticMethods.logWarningFormat("Messages - content view is in undefined state (%s)", ex.getMessage());\n                finish();\n                overridePendingTransition(0, 0);\n            }\n        }\n    }', 'summary': " It first initializes a 'ViewGroup' variable 'rootViewGroup' with the 'findViewById' method. It then checks if the 'rootViewGroup' variable is null, and if so, it logs an error message. If the 'rootViewGroup' variable is not null, it posts a 'Runnable' object to the 'rootViewGroup' to show the message in the root view group.", 'children': {'java.lang.String getMessage()': ' It is a simple Python function that defines a message that can be used when a user tries to access a non-existent attribute of an object. The function takes a single argument (the name of the attribute that was accessed), and returns a string message indicating that the attribute does not exist.\n\ndef getMessage(attr):\n    return f"The attribute \'{attr}\' does not exist."', 'void run()': " It is a simple Python script that defines a function called 'run' that takes a parameter called 'None'. The function does not do anything with the provided 'None' parameter and simply returns 'None'.", 'void logErrorFormat(java.lang.String,java.lang.Object[])': " It is a Java method that takes a format string and an array of arguments. It then logs the formatted string to the 'ADBMobile' log tag. The method checks if the array of arguments is null or has a length of 0, and if so, it logs the unformatted string to the 'ADBMobile' log tag.", 'void logWarningFormat(java.lang.String,java.lang.Object[])': ' It is a Java method that takes a format string and an array of arguments. It first checks if debug logging is enabled, and if so, it logs the formatted string using the provided arguments. If debug logging is not enabled, it only logs the format string.'}}, 'Entry-point: <com.adobe.mobile.MessageFullScreenActivity: void onSaveInstanceState(android.os.Bundle)>': {'entry_point name': 'void onSaveInstanceState(android.os.Bundle)', 'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        outState.putString(MESSAGE_STATE_MESSAGE_ID, this.message.messageId);\n        outState.putString(MESSAGE_STATE_REPLACED_HTML, this.message.replacedHtml);\n        super.onSaveInstanceState(outState);\n    }', 'summary': ' It saves the current message ID and replaced HTML in the instance state bundle, which can then be used to restore the message ID and replaced HTML when the activity is recreated.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        Config.setContext(getApplicationContext());\n    }', 'summary': ' It creates a new instance of the Config class and sets the context to the current application context. The Config class is a utility class that is used to store global application-wide properties.', 'children': {'void setContext(android.content.Context)': " It sets the context of the current application to 'ApplicationType.APPLICATION_TYPE_HANDHELD'. This context can be used to determine the behavior of the application in different scenarios, e.g., when it is used in a mobile app or in a desktop app.", 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onPause()>': {'entry_point name': 'void onPause()', 'code': 'void  onPause()  {\n        super.onPause();\n        Config.pauseCollectingLifecycleData();\n    }', 'summary': ' It pauses the collection of lifecycle data in the Config class, which is used by the AppLovin SDK to track session and event data.', 'children': {'void pauseCollectingLifecycleData()': ' It first checks if the app is running on a wearable device, and if so, it logs a warning message. Otherwise, it stops the lifecycle data collection by calling the `stop` method on the `Lifecycle` class.', 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.adobe.mobile.AdobeMarketingActivity: void onResume()>': {'entry_point name': 'void onResume()', 'code': 'void  onResume()  {\n        super.onResume();\n        Config.collectLifecycleData(this);\n    }', 'summary': ' It collects lifecycle data by calling the Config.collectLifecycleData(this) method. The Config class is a custom class that is used to store application-wide configuration settings.', 'children': {'void collectLifecycleData(android.app.Activity)': ' It first checks if the app is running on a wearable device, and if not, it starts the lifecycle tracking using the `Lifecycle.start` method. The `Lifecycle.start` method is provided by the Adobe Mobile SDK, and it is used to start the lifecycle tracking for non-wearable apps. The provided code uses a `Runnable` object to execute the `Lifecycle.start` method on a separate thread, which ensures that the main thread is not blocked while the lifecycle tracking is started.', 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onActivityResult(int,int,android.content.Intent)>': {'entry_point name': 'void onActivityResult(int,int,android.content.Intent)', 'code': 'void  onActivityResult(int,int,android.content.Intent)  {\n        super.onActivityResult(i, i2, intent);\n        if (i == 1) {\n            boolean booleanExtra = getIntent().getBooleanExtra("notify_manager", true);\n            this.zabp = 0;\n            setResult(i2, intent);\n            if (booleanExtra) {\n                GoogleApiManager zab = GoogleApiManager.zab(this);\n                switch (i2) {\n                    case -1:\n                        zab.zao();\n                        break;\n                    case 0:\n                        zab.zaa(new ConnectionResult(13, null), getIntent().getIntExtra("failing_client_id", -1));\n                        break;\n                }\n            }\n        } else if (i == 2) {\n            this.zabp = 0;\n            setResult(i2, intent);\n        }\n        finish();\n    }', 'summary': " It first checks if the request code is 1. If it is, it extracts a boolean value from the intent using the 'getBooleanExtra' method. If this value is true, it initializes a new `GoogleApiManager` object using the 'zab' function and then checks the result code. If the result code is -1, it calls the 'zao' function on the `GoogleApiManager` object to start the resolution process. If the result code is 0, it calls the 'zaa' function with a `ConnectionResult` object containing an error code of 13 and a null error message. The 'failing_client_id' extra is used to identify the ID of the client that failed to connect.", 'children': {'void zao()': " It declares a class called 'Zao' that extends the 'Handler' class. It then overrides the 'handleMessage' method and sends a message with ID 3 to the handler using the 'obtainMessage' method. The 'obtainMessage' method is inherited from the 'Handler' class and is used to create a new message. The message ID is used to identify the type of message that is being sent. In this case, the message is a notification message, which is used to notify the user that something has happened.", 'void zaa(com.google.android.gms.common.ConnectionResult,int)': ' It appears to create a new instance of GoogleApiManager and call its constructor with the provided parameters. It then calls the zabr() method, which is not defined in the class.', 'com.google.android.gms.common.api.internal.GoogleApiManager zab(android.content.Context)': ' It first initializes a `GoogleApiManager` object with the `GoogleApiAvailability` instance. Then, it checks if the `zaic` object is null, and if so, it creates a new `HandlerThread` with the name "GoogleApiHandler" and priority 9. After that, it starts the `HandlerThread`. After that, it creates a new `GoogleApiManager` object with the `context.getApplicationContext()` and the `handlerThread.getLooper()`. Finally, it returns the `GoogleApiManager` object.\n\nThe provided code is not thread-safe, because it creates a new `GoogleApiManager` object each time the method is called. To make the code thread-safe, you can use the following code:\n\n  zab  {\n        GoogleApiManager googleApiManager;\n        synchronized (lock) {\n            if (zaic == null) {\n                HandlerThread handlerThread = new HandlerThread("GoogleApiHandler", 9);\n                handlerThread.start();\n                zaic = new GoogleApiManager(context.getApplicationContext(), handlerThread.getLooper(), GoogleApiAvailability.getInstance());\n            }\n            googleApiManager = zaic;\n        }\n        return googleApiManager;\n    }'}}, 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(bundle);\n        if (bundle != null) {\n            this.zabp = bundle.getInt("resolution");\n        }\n        if (this.zabp != 1) {\n            Bundle extras = getIntent().getExtras();\n            if (extras == null) {\n                Log.e("GoogleApiActivity", "Activity started without extras");\n                finish();\n                return;\n            }\n            PendingIntent pendingIntent = (PendingIntent) extras.get("pending_intent");\n            Integer num = (Integer) extras.get("error_code");\n            if (pendingIntent == null && num == null) {\n                Log.e("GoogleApiActivity", "Activity started without resolution");\n                finish();\n            } else if (pendingIntent != null) {\n                try {\n                    startIntentSenderForResult(pendingIntent.getIntentSender(), 1, null, 0, 0, 0);\n                    this.zabp = 1;\n                } catch (IntentSender.SendIntentException e) {\n                    Log.e("GoogleApiActivity", "Failed to launch pendingIntent", e);\n                    finish();\n                }\n            } else {\n                GoogleApiAvailability.getInstance().showErrorDialogFragment(this, num.intValue(), 2, this);\n                this.zabp = 1;\n            }\n        }\n    }', 'summary': " It declares two variables 'zabp' and 'pendingIntent', assigns them default values, and then checks for the presence of extras in the intent. If the extras are not present, it logs an error message and finishes the activity. If the extras are present, it checks for the'resolution' key in the bundle. If the'resolution' key is not present, it logs an error message and finishes the activity. If the'resolution' key is present, it assigns the value of'resolution' to 'zabp' and sets 'pendingIntent' to the value of the 'pending_intent' extra. It then attempts to start the activity using the 'pendingIntent' object, which will either launch the resolution activity or display the error dialog depending on the value of 'zabp'. If the activity fails to launch, it logs an error message and finishes the activity. If the activity is launched successfully, it sets 'zabp' to 1 to indicate that the error dialog was shown successfully.", 'children': {'boolean showErrorDialogFragment(android.app.Activity,int,int,android.content.DialogInterface$OnCancelListener)': ' It is a method that is used to display an error dialog in a fragment. It takes the activity that the fragment is currently attached to, an error message, and two optional listener objects. It returns true if the error dialog was shown successfully, false otherwise.', 'int e(java.lang.String,java.lang.String)': " It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.", 'int e(java.lang.String,java.lang.String,java.lang.Throwable)': " It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.", 'com.google.android.gms.common.GoogleApiAvailability getInstance()': " It declares a Java method called 'getInstance' that returns the 'zaao' object. It is used as a singleton, which ensures that only one instance of the 'zaao' class is created."}}, 'Entry-point: <com.google.android.gms.common.api.GoogleApiActivity: void onSaveInstanceState(android.os.Bundle)>': {'entry_point name': 'void onSaveInstanceState(android.os.Bundle)', 'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        bundle.putInt("resolution", this.zabp);\n        super.onSaveInstanceState(bundle);\n    }', 'summary': " It is saving the current value of the private variable 'zabp' (which represents the current resolution) into the 'bundle' before calling the superclass method. This is necessary because the superclass method will be called when the activity is destroyed, which will happen when the user rotates the device or navigates away from the activity. If the current resolution is not saved, the activity will be restored with the default resolution (1080x1920) which will result in a large amount of screen space being used, which is not ideal.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerNativeActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        Log.w("Unity", "UnityPlayerNativeActivity has been deprecated, please update your AndroidManifest to use UnityPlayerActivity instead");\n        super.onCreate(bundle);\n    }', 'summary': " It's designed to log a warning message in the Android logcat, which is a system log that can be accessed using the 'Logcat' command in the Android Debugging Tools. The message is shown when the deprecated 'UnityPlayerNativeActivity' is used in the AndroidManifest.xml. It's recommened to use the new 'UnityPlayerActivity' instead, which is a subclass of 'UnityPlayerNativeActivity' that has been updated to properly handle the transition to the new Android Activity Lifecycle.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <net.gree.unitywebview.CUnityPlayerActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        requestWindowFeature(1);\n        super.onCreate(bundle);\n        getWindow().setFormat(2);\n        this.mUnityPlayer = new CUnityPlayer(this);\n        setContentView(this.mUnityPlayer);\n        this.mUnityPlayer.requestFocus();\n    }', 'summary': ' It appears to set the window format to RGB565, which is a 16-bit color format. However, it does not actually do this. The method `getWindow().setFormat(2);` is a no-op, and the window format will remain unchanged. The correct way to set the window format is to use `getWindow().setFormat(PixelFormat.RGB_565);`, as shown in the following code:\n\nvoid  onCreate(android.os.Bundle)  {\n        requestWindowFeature(1);\n        super.onCreate(bundle);\n        getWindow().setFormat(PixelFormat.RGB_565);\n        this.mUnityPlayer = new CUnityPlayer(this);\n        setContentView(this.mUnityPlayer);\n        this.mUnityPlayer.requestFocus();\n    }', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean dispatchKeyEvent(android.view.KeyEvent)>': {'entry_point name': 'boolean dispatchKeyEvent(android.view.KeyEvent)', 'code': 'boolean  dispatchKeyEvent(android.view.KeyEvent)  {\n        return keyEvent.getAction() == 2 ? this.mUnityPlayer.injectEvent(keyEvent) : super.dispatchKeyEvent(keyEvent);\n    }', 'summary': ' It appears to override the dispatchKeyEvent method of the Activity class, which is called when an event is dispatched to the activity. The code checks if the key event is a key up event (ACTION_UP == 2) and, if so, it sends the event to the Unity player using the injectEvent method. If the key event is not a key up event, it is passed to the superclass (calling the original dispatchKeyEvent method) for handling.\n\nThe provided code is designed to work with the Unity player. The injectEvent method is part of the UnityPlayer class, which is a Java interface with a corresponding implementation in the UnityPlayerActivity class. The interface allows the Unity player to pass events to the activity, which handles them appropriately.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onConfigurationChanged(android.content.res.Configuration)>': {'entry_point name': 'void onConfigurationChanged(android.content.res.Configuration)', 'code': 'void  onConfigurationChanged(android.content.res.Configuration)  {\n        super.onConfigurationChanged(configuration);\n        this.mUnityPlayer.configurationChanged(configuration);\n    }', 'summary': ' It appears to register a callback with the Android OS that is invoked when the device configuration changes. In the provided code, the callback is invoked by calling the `onConfigurationChanged` method on the `UnityPlayer` instance, which in turn calls the `configurationChanged` method on the `UnityPlayer` Java class. The `configurationChanged` method is a no-op in the base `UnityPlayer` class, but can be overridden by subclasses to provide custom behavior. In this case, the `UnityPlayer` base class is used directly, so the `configurationChanged` method is a no-op. The provided code also uses the `super` keyword, which is a reference to the parent class, in order to invoke the `onConfigurationChanged` method on the parent class. This ensures that the correct method is called for any subclasses that override the `UnityPlayer` class.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        requestWindowFeature(1);\n        super.onCreate(bundle);\n        this.mUnityPlayer = new UnityPlayer(this);\n        setContentView(this.mUnityPlayer);\n        this.mUnityPlayer.requestFocus();\n    }', 'summary': " It's not clear from the code itself what it does. It appears to create a new UnityPlayer instance and set it as the content view of the activity. It also requests focus for the UnityPlayer instance, which is necessary to receive input events from the Unity Player.", 'children': {'boolean requestFocus()': ' It is used to request focus on the specified component, but in this case, the specified component is None, which means that the focus will be requested on the entire window.', 'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onDestroy()>': {'entry_point name': 'void onDestroy()', 'code': 'void  onDestroy()  {\n        this.mUnityPlayer.quit();\n        super.onDestroy();\n    }', 'summary': " It's registering an Android lifecycle callback method (onDestroy) that is called when the Activity is destroyed. In the provided code, the method is quitting the Unity player, which is necessary to properly shutdown the Unity environment. Finally, it's calling the superclass' (Activity) onDestroy method, which is necessary to ensure proper cleanup of the Activity.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean onGenericMotionEvent(android.view.MotionEvent)>': {'entry_point name': 'boolean onGenericMotionEvent(android.view.MotionEvent)', 'code': 'boolean  onGenericMotionEvent(android.view.MotionEvent)  {\n        return this.mUnityPlayer.injectEvent(motionEvent);\n    }', 'summary': " It's designed to forward Android touch events to the Unity player, which is running the game. The method returns true if the event was handled by the Unity player, and false otherwise.\n\nThe provided code forwards the Android MotionEvent to the Unity player by calling the 'injectEvent' method on the'mUnityPlayer' object. The 'injectEvent' method returns true if the event was handled by the player, and false otherwise.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean onKeyDown(int,android.view.KeyEvent)>': {'entry_point name': 'boolean onKeyDown(int,android.view.KeyEvent)', 'code': 'boolean  onKeyDown(int,android.view.KeyEvent)  {\n        return this.mUnityPlayer.injectEvent(keyEvent);\n    }', 'summary': ' It appears to register an Android key event listener on the current Activity, which will then forward the key event to the Unity player when it is ready. The function returns true if the key event was handled by the Unity player, and false otherwise.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean onKeyUp(int,android.view.KeyEvent)>': {'entry_point name': 'boolean onKeyUp(int,android.view.KeyEvent)', 'code': 'boolean  onKeyUp(int,android.view.KeyEvent)  {\n        return this.mUnityPlayer.injectEvent(keyEvent);\n    }', 'summary': ' It appears to register an Android key event listener (onKeyUp) that forwards the key event to the Unity player. The function returns true if the event was handled by the Unity player, otherwise false.\n\nThe provided code is part of a class that extends the UnityPlayerActivity. The class overrides the onKeyUp function to forward key events to the Unity player.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onLowMemory()>': {'entry_point name': 'void onLowMemory()', 'code': 'void  onLowMemory()  {\n        super.onLowMemory();\n        this.mUnityPlayer.lowMemory();\n    }', 'summary': ' It appears to register an Android activity callback that is called when the app is running low on memory. It then calls the `lowMemory` method on the Unity player object, which is used to free unused resources.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onNewIntent(android.content.Intent)>': {'entry_point name': 'void onNewIntent(android.content.Intent)', 'code': 'void  onNewIntent(android.content.Intent)  {\n        setIntent(intent);\n    }', 'summary': " It appears to register an activity lifecycle callback that sets the current activity's intent to the provided intent. The callback is called when the activity is created from a new intent, e.g., when the user clicks on an app icon in the launcher. The provided code is not actually functional and will not affect the behavior of the app.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onPause()>': {'entry_point name': 'void onPause()', 'code': 'void  onPause()  {\n        super.onPause();\n        this.mUnityPlayer.pause();\n    }', 'summary': ' It pauses the Unity player when the app is paused.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onResume()>': {'entry_point name': 'void onResume()', 'code': 'void  onResume()  {\n        super.onResume();\n        this.mUnityPlayer.resume();\n    }', 'summary': ' It is registering an activity lifecycle callback method (onResume) that will be invoked when the activity is resumed. In the callback method, it is calling the UnityPlayer (mUnityPlayer) resume method, which will cause the Unity content to be rendered.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onStart()>': {'entry_point name': 'void onStart()', 'code': 'void  onStart()  {\n        super.onStart();\n        this.mUnityPlayer.start();\n    }', 'summary': ' It starts a new activity in the AndroidManifest.xml file and then initializes the Unity player. The onStart() method is a lifecycle callback that is called when the activity is created. In this case, it is used to start the Unity player.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onStop()>': {'entry_point name': 'void onStop()', 'code': 'void  onStop()  {\n        super.onStop();\n        this.mUnityPlayer.stop();\n    }', 'summary': ' It is designed to override the `onStop()` method of the `Activity` class, which is called when the activity is about to stop. In this case, it is used to stop the Unity player, which is running in the background.', 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>': {'entry_point name': 'boolean onTouchEvent(android.view.MotionEvent)', 'code': 'boolean  onTouchEvent(android.view.MotionEvent)  {\n        return this.mUnityPlayer.injectEvent(motionEvent);\n    }', 'summary': " It's designed to forward touch events to the Unity player, which is running the game. The code declares a boolean function 'onTouchEvent' that takes a 'MotionEvent' as an input. It then returns the result of calling the 'injectEvent' function on the Unity player instance, which is provided as a member variable. This means that the function will return true if the event was successfully injected, and false otherwise.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onTrimMemory(int)>': {'entry_point name': 'void onTrimMemory(int)', 'code': 'void  onTrimMemory(int)  {\n        super.onTrimMemory(i);\n        if (i == 15) {\n            this.mUnityPlayer.lowMemory();\n        }\n    }', 'summary': " It's registering an `onTrimMemory` callback with the Android Activity Manager. The callback is invoked when the system needs to free up memory. The provided code is checking for the `TRIM_MEMORY_RUNNING_LOW` constant, which is used to indicate that the system is running low on memory. If the callback is invoked with this constant, it's instructing the `UnityPlayer` to release unused memory.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerActivity: void onWindowFocusChanged(boolean)>': {'entry_point name': 'void onWindowFocusChanged(boolean)', 'code': 'void  onWindowFocusChanged(boolean)  {\n        super.onWindowFocusChanged(z);\n        this.mUnityPlayer.windowFocusChanged(z);\n    }', 'summary': " It's registering an override for the `onWindowFocusChanged` method in the `UnityPlayerActivity` class. The override is calling the superclass implementation of the method and then forwarding the call to the `UnityPlayer` instance, which is used to interact with the Unity Engine. The `windowFocusChanged` method is a part of the `UnityPlayer` class and is used to notify the Unity Engine about the change in the window focus.", 'children': {'None': 'No children functions found, no summary generated.'}}, 'Entry-point: <com.unity3d.player.UnityPlayerProxyActivity: void onCreate(android.os.Bundle)>': {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        Log.w("Unity", "UnityPlayerProxyActivity has been deprecated, please update your AndroidManifest to use UnityPlayerActivity instead");\n        super.onCreate(bundle);\n    }', 'summary': ' It\'s designed to log a warning message in the Android logcat, which is a system log that can be accessed using \'adb logcat\' command. The message is displayed only once, so it will not be repeated if the app is restarted. The code uses the \'Log.w\' method, which is a static method in the \'Log\' class. The first parameter is the tag, which is used to identify the source of the message. In this case, the tag is \'Unity\'. The second parameter is the message itself.\n\nThe provided code is designed to support the old \'UnityPlayerProxyActivity\' class, which has been deprecated in favor of the new \'UnityPlayerActivity\' class. The new class is more efficient and does not require any additional permissions, so it\'s recommended to use it instead of the old one. The updated code should look like this:\n\nvoid  onCreate(android.os.Bundle)  {\n        Log.w("Unity", "The \'UnityPlayerProxyActivity\' class has been deprecated, please update your AndroidManifest to use the \'UnityPlayerActivity\' class instead.");\n        super.onCreate(bundle);\n    }', 'children': {'int w(java.lang.String,java.lang.String)': " It declares a variable 'w' and assigns it the value 'None'. Then, it prints the value of 'w' to the console, which will be 'None'.", 'None': 'No children functions found, no summary generated.'}}}
Saving output...
Writing to text file...
Entry point data: {'entry_point name': 'void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])', 'code': 'void  dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])  {\n        super.dump(prefix, fd, writer, args);\n        writer.print(prefix);\n        writer.print("Local FragmentActivity ");\n        writer.print(Integer.toHexString(System.identityHashCode(this)));\n        writer.println(" State:");\n        String innerPrefix = prefix + "  ";\n        writer.print(innerPrefix);\n        writer.print("mCreated=");\n        writer.print(this.mCreated);\n        writer.print(" mResumed=");\n        writer.print(this.mResumed);\n        writer.print(" mStopped=");\n        writer.print(this.mStopped);\n        if (getApplication() != null) {\n            LoaderManager.getInstance(this).dump(innerPrefix, fd, writer, args);\n        }\n        this.mFragments.getSupportFragmentManager().dump(prefix, fd, writer, args);\n    }', 'summary': " It first prints a prefix, then it prints the value of the'mId' field, then it prints the value of the'mArgs' field, then it prints the loader, and finally it dumps the loader's data. The provided code is designed to provide a concise and readable representation of the Loader's internal state.  It calculates the hash code of the object 'None' using the 'identityHashCode' method, which returns the same hash code for every 'None' instance.  It converts a number to a hexadecimal string representation. However, it does not provide any input validation, so it's possible to generate an invalid hexadecimal string if the input is not a number. For example, calling `toHexString(NaN)` will generate the string 'NaN', which is not a valid hexadecimal string.  It declares a method called 'getInstance' that returns a new instance of the 'LoaderManagerImpl' class. It takes two arguments: 'owner' and'store'. The 'owner' argument is a reference to the object that owns the new instance, and the'store' argument is a reference to the View Model Store that the owner will use to store its View Models. The method first creates a new instance of the 'LoaderManagerImpl' class, and then initializes it with the provided 'owner' and'store' arguments. Finally, it returns the new instance.", 'children': {'void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])': " It first prints a prefix, then it prints the value of the'mId' field, then it prints the value of the'mArgs' field, then it prints the loader, and finally it dumps the loader's data. The provided code is designed to provide a concise and readable representation of the Loader's internal state.", 'int identityHashCode(java.lang.Object)': " It calculates the hash code of the object 'None' using the 'identityHashCode' method, which returns the same hash code for every 'None' instance.", 'java.lang.String toHexString(int)': " It converts a number to a hexadecimal string representation. However, it does not provide any input validation, so it's possible to generate an invalid hexadecimal string if the input is not a number. For example, calling `toHexString(NaN)` will generate the string 'NaN', which is not a valid hexadecimal string.", 'androidx.loader.app.LoaderManager getInstance(androidx.lifecycle.LifecycleOwner)': " It declares a method called 'getInstance' that returns a new instance of the 'LoaderManagerImpl' class. It takes two arguments: 'owner' and'store'. The 'owner' argument is a reference to the object that owns the new instance, and the'store' argument is a reference to the View Model Store that the owner will use to store its View Models. The method first creates a new instance of the 'LoaderManagerImpl' class, and then initializes it with the provided 'owner' and'store' arguments. Finally, it returns the new instance."}}
Entry point data children: {'void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])': " It first prints a prefix, then it prints the value of the'mId' field, then it prints the value of the'mArgs' field, then it prints the loader, and finally it dumps the loader's data. The provided code is designed to provide a concise and readable representation of the Loader's internal state.", 'int identityHashCode(java.lang.Object)': " It calculates the hash code of the object 'None' using the 'identityHashCode' method, which returns the same hash code for every 'None' instance.", 'java.lang.String toHexString(int)': " It converts a number to a hexadecimal string representation. However, it does not provide any input validation, so it's possible to generate an invalid hexadecimal string if the input is not a number. For example, calling `toHexString(NaN)` will generate the string 'NaN', which is not a valid hexadecimal string.", 'androidx.loader.app.LoaderManager getInstance(androidx.lifecycle.LifecycleOwner)': " It declares a method called 'getInstance' that returns a new instance of the 'LoaderManagerImpl' class. It takes two arguments: 'owner' and'store'. The 'owner' argument is a reference to the object that owns the new instance, and the'store' argument is a reference to the View Model Store that the owner will use to store its View Models. The method first creates a new instance of the 'LoaderManagerImpl' class, and then initializes it with the provided 'owner' and'store' arguments. Finally, it returns the new instance."}
Child function name: void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])
Child summary:  It first prints a prefix, then it prints the value of the'mId' field, then it prints the value of the'mArgs' field, then it prints the loader, and finally it dumps the loader's data. The provided code is designed to provide a concise and readable representation of the Loader's internal state.
Child function name: int identityHashCode(java.lang.Object)
Child summary:  It calculates the hash code of the object 'None' using the 'identityHashCode' method, which returns the same hash code for every 'None' instance.
Child function name: java.lang.String toHexString(int)
Child summary:  It converts a number to a hexadecimal string representation. However, it does not provide any input validation, so it's possible to generate an invalid hexadecimal string if the input is not a number. For example, calling `toHexString(NaN)` will generate the string 'NaN', which is not a valid hexadecimal string.
Child function name: androidx.loader.app.LoaderManager getInstance(androidx.lifecycle.LifecycleOwner)
Child summary:  It declares a method called 'getInstance' that returns a new instance of the 'LoaderManagerImpl' class. It takes two arguments: 'owner' and'store'. The 'owner' argument is a reference to the object that owns the new instance, and the'store' argument is a reference to the View Model Store that the owner will use to store its View Models. The method first creates a new instance of the 'LoaderManagerImpl' class, and then initializes it with the provided 'owner' and'store' arguments. Finally, it returns the new instance.
Entry point data: {'entry_point name': 'void onActivityResult(int,int,android.content.Intent)', 'code': 'void  onActivityResult(int,int,android.content.Intent)  {\n        this.mFragments.noteStateNotSaved();\n        int requestIndex = requestCode >> 16;\n        if (requestIndex != 0) {\n            int requestIndex2 = requestIndex - 1;\n            String who = this.mPendingFragmentActivityResults.get(requestIndex2);\n            this.mPendingFragmentActivityResults.remove(requestIndex2);\n            if (who == null) {\n                Log.w(TAG, "Activity result delivered for unknown Fragment.");\n                return;\n            }\n            Fragment targetFragment = this.mFragments.findFragmentByWho(who);\n            if (targetFragment == null) {\n                Log.w(TAG, "Activity result no fragment exists for who: " + who);\n                return;\n            } else {\n                targetFragment.onActivityResult(65535 & requestCode, resultCode, data);\n                return;\n            }\n        }\n        ActivityCompat.PermissionCompatDelegate delegate = ActivityCompat.getPermissionCompatDelegate();\n        if (delegate == null || !delegate.onActivityResult(this, requestCode, resultCode, data)) {\n            super.onActivityResult(requestCode, resultCode, data);\n        }\n    }', 'summary': " It appears to handle activity results for Fragments, but it's not clear what it actually does. The code checks for a request code greater than 65535, which is the maximum value for a 16-bit integer. If this is true, it means the code is handling a result for a Fragment, so it divides the request code by 65536 and uses the remainder as an index into an array of pending Fragment activity results. If the index is 0, it means the activity result is not for a Fragment, so it calls the superclass method. If the index is not 0, it retrieves the name of the Fragment that the activity result is for and uses it to find the target Fragment in the Fragment manager. If the target Fragment is found, it calls the target Fragment's `onActivityResult` method with the lower 16 bits of the request code and the other parameters. If the target Fragment is not found, it logs a warning.", 'children': {'androidx.core.app.ActivityCompat$PermissionCompatDelegate getPermissionCompatDelegate()': " It declares a method called 'getPermissionCompatDelegate' that returns the static'sDelegate' field. It is used to provide backwards compatibility with older versions of the Android permission API.", 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'androidx.core.app.ActivityCompat$PermissionCompatDelegate getPermissionCompatDelegate()': " It declares a method called 'getPermissionCompatDelegate' that returns the static'sDelegate' field. It is used to provide backwards compatibility with older versions of the Android permission API.", 'None': 'No children functions found, no summary generated.'}
Child function name: androidx.core.app.ActivityCompat$PermissionCompatDelegate getPermissionCompatDelegate()
Child summary:  It declares a method called 'getPermissionCompatDelegate' that returns the static'sDelegate' field. It is used to provide backwards compatibility with older versions of the Android permission API.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'void onBackPressed()', 'code': 'void  onBackPressed()  {\n        FragmentManager fragmentManager = this.mFragments.getSupportFragmentManager();\n        boolean isStateSaved = fragmentManager.isStateSaved();\n        if (!isStateSaved || Build.VERSION.SDK_INT > 25) {\n            if (isStateSaved || !fragmentManager.popBackStackImmediate()) {\n                super.onBackPressed();\n            }\n        }\n    }', 'summary': ' It first checks if the fragment manager is in a saved state, and if not, it pops the back stack. However, it only does this if the SDK version is below 26. If the SDK version is 26 or higher, it will always pop the back stack, even if it is in a saved state. This is because the new FragmentManager.popBackStackImmediate() method restores the state of the manager if it is saved, and the old method does not.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onConfigurationChanged(android.content.res.Configuration)', 'code': 'void  onConfigurationChanged(android.content.res.Configuration)  {\n        super.onConfigurationChanged(newConfig);\n        this.mFragments.noteStateNotSaved();\n        this.mFragments.dispatchConfigurationChanged(newConfig);\n    }', 'summary': ' It appears to register a listener for configuration changes and then call the `dispatchConfigurationChanged` method on the `FragmentManager`. However, it does not provide any explanation as to why this is necessary or what it achieves.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        this.mFragments.attachHost(null);\n        super.onCreate(savedInstanceState);\n        NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance();\n        if (nc != null && nc.viewModelStore != null && this.mViewModelStore == null) {\n            this.mViewModelStore = nc.viewModelStore;\n        }\n        if (savedInstanceState != null) {\n            Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);\n            this.mFragments.restoreAllState(p, nc != null ? nc.fragments : null);\n            if (savedInstanceState.containsKey(NEXT_CANDIDATE_REQUEST_INDEX_TAG)) {\n                this.mNextCandidateRequestIndex = savedInstanceState.getInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG);\n                int[] requestCodes = savedInstanceState.getIntArray(ALLOCATED_REQUEST_INDICIES_TAG);\n                String[] fragmentWhos = savedInstanceState.getStringArray(REQUEST_FRAGMENT_WHO_TAG);\n                if (requestCodes == null || fragmentWhos == null || requestCodes.length != fragmentWhos.length) {\n                    Log.w(TAG, "Invalid requestCode mapping in savedInstanceState.");\n                } else {\n                    this.mPendingFragmentActivityResults = new SparseArrayCompat<>(requestCodes.length);\n                    for (int i = 0; i < requestCodes.length; i++) {\n                        this.mPendingFragmentActivityResults.put(requestCodes[i], fragmentWhos[i]);\n                    }\n                }\n            }\n        }\n        if (this.mPendingFragmentActivityResults == null) {\n            this.mPendingFragmentActivityResults = new SparseArrayCompat<>();\n            this.mNextCandidateRequestIndex = 0;\n        }\n        this.mFragments.dispatchCreate();\n    }', 'summary': " It first initializes a `NonConfigurationInstances` object with the last non-configuration instance (if any) and then checks if the `NonConfigurationInstances` object has a `viewModelStore` field set. If this is the case, it assigns the `viewModelStore` field of the `NonConfigurationInstances` object to the `mViewModelStore` field of the `FragmentActivity` instance. Next, it checks if there is a saved instance state in the provided `savedInstanceState` parameter. If this is the case, it restores the activity's fragments from the saved state and assigns the saved `nextCandidateRequestIndex` value to the `mNextCandidateRequestIndex` field. If there is an invalid request code mapping in the saved instance state, a `Log.w` message is printed. Finally, it initializes a `SparseArrayCompat` for pending fragment activity results and assigns it to the `mPendingFragmentActivityResults` field.", 'children': {'void put(int,java.lang.Object)': ' It first initializes two arrays, mKeys and mValues, with the size of the expected storage (mSize). Then it searches for the position of the given key in the array using the binarySearch method. If the key is found, it updates the value at that position. If the key is not found, it searches for a position where the key can be inserted without violating the ordering. If there is an empty position, it inserts the key-value pair there. If there is no empty position, it doubles the size of the arrays and inserts the key-value pair at the new position.', 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'void put(int,java.lang.Object)': ' It first initializes two arrays, mKeys and mValues, with the size of the expected storage (mSize). Then it searches for the position of the given key in the array using the binarySearch method. If the key is found, it updates the value at that position. If the key is not found, it searches for a position where the key can be inserted without violating the ordering. If there is an empty position, it inserts the key-value pair there. If there is no empty position, it doubles the size of the arrays and inserts the key-value pair at the new position.', 'None': 'No children functions found, no summary generated.'}
Child function name: void put(int,java.lang.Object)
Child summary:  It first initializes two arrays, mKeys and mValues, with the size of the expected storage (mSize). Then it searches for the position of the given key in the array using the binarySearch method. If the key is found, it updates the value at that position. If the key is not found, it searches for a position where the key can be inserted without violating the ordering. If there is an empty position, it inserts the key-value pair there. If there is no empty position, it doubles the size of the arrays and inserts the key-value pair at the new position.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'boolean onCreatePanelMenu(int,android.view.Menu)', 'code': 'boolean  onCreatePanelMenu(int,android.view.Menu)  {\n        if (featureId == 0) {\n            boolean show = super.onCreatePanelMenu(featureId, menu);\n            return show | this.mFragments.dispatchCreateOptionsMenu(menu, getMenuInflater());\n        }\n        boolean show2 = super.onCreatePanelMenu(featureId, menu);\n        return show2;\n    }', 'summary': ' It appears to create a menu item for the activity, and then dispatch the creation of the menu items to the fragments attached to the activity. The question is: why is the code dispatching the menu creation to the fragments when the activity is already creating the menu?', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onDestroy()', 'code': 'void  onDestroy()  {\n        super.onDestroy();\n        if (this.mViewModelStore != null && !isChangingConfigurations()) {\n            this.mViewModelStore.clear();\n        }\n        this.mFragments.dispatchDestroy();\n    }', 'summary': " It first initializes a ViewModelStore instance (this.mViewModelStore) and then checks if the Activity is not in the process of being re-created (isChangingConfigurations()). If the Activity is not being re-created, it clears the ViewModelStore instance (this.mViewModelStore.clear()). Finally, it dispatches the Activity's onDestroy() to its fragments (this.mFragments.dispatchDestroy()).", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onLowMemory()', 'code': 'void  onLowMemory()  {\n        super.onLowMemory();\n        this.mFragments.dispatchLowMemory();\n    }', 'summary': " It's registering an `onLowMemory` callback with the Activity's FragmentManager. The callback is then invoked when the Activity's memory is low, which is detected by the Android system. The callback is then delegating the call to the Activity's base class, which in turn calls the `onLowMemory` method on the Activity. The `onLowMemory` method in the Activity is then responsible for freeing any memory that it's holding.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'boolean onMenuItemSelected(int,android.view.MenuItem)', 'code': 'boolean  onMenuItemSelected(int,android.view.MenuItem)  {\n        if (super.onMenuItemSelected(featureId, item)) {\n            return true;\n        }\n        switch (featureId) {\n            case 0:\n                return this.mFragments.dispatchOptionsItemSelected(item);\n            case 6:\n                return this.mFragments.dispatchContextItemSelected(item);\n            default:\n                return false;\n        }\n    }', 'summary': ' It appears to be a method that is called when a menu item is selected. It first checks if the item was handled by the superclass (this will be true for items in the main menu, such as "Save" or "Share"), and if not, it checks if the item is part of a fragment container (0 or 6). If so, it dispatches the item to the appropriate fragment container. If not, it returns false, indicating that the item was not handled.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onMultiWindowModeChanged(boolean)', 'code': 'void  onMultiWindowModeChanged(boolean)  {\n        this.mFragments.dispatchMultiWindowModeChanged(isInMultiWindowMode);\n    }', 'summary': " It's registering a callback with the Activity's FragmentManager, which will be invoked when the multi-window mode changes. The callback is provided with a boolean parameter indicating the new multi-window mode. The callback is then dispatching the mode change to all registered Fragments using the FragmentManager's `dispatchMultiWindowModeChanged` method.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onNewIntent(android.content.Intent)', 'code': 'void  onNewIntent(android.content.Intent)  {\n        super.onNewIntent(intent);\n        this.mFragments.noteStateNotSaved();\n    }', 'summary': " It appears to register an activity lifecycle callback that is used to notify the FragmentManager that the activity state has changed and not all fragments have been saved. The callback is invoked in the superclass, which in this case is Activity. In the provided code, the callback is overridden and the FragmentManager's state is explicitly saved.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onPanelClosed(int,android.view.Menu)', 'code': 'void  onPanelClosed(int,android.view.Menu)  {\n        switch (featureId) {\n            case 0:\n                this.mFragments.dispatchOptionsMenuClosed(menu);\n                break;\n        }\n        super.onPanelClosed(featureId, menu);\n    }', 'summary': " It appears to register an `onPanelClosed` callback for a specific feature ID (0). When the panel with the given feature ID is closed, the provided code dispatches the `OptionsMenu` to all registered fragments and then calls the superclass' `onPanelClosed` method. The superclass' `onPanelClosed` method is empty, so it does not actually do anything. The provided code is designed to be overridden by subclasses, so it is important to analyze it correctly.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onPause()', 'code': 'void  onPause()  {\n        super.onPause();\n        this.mResumed = false;\n        if (this.mHandler.hasMessages(2)) {\n            this.mHandler.removeMessages(2);\n            onResumeFragments();\n        }\n        this.mFragments.dispatchPause();\n    }', 'summary': ' It appears to override the `onPause` method of the Activity, which is used to pause the activity when the user switches to another application or to the home screen. The code checks if there are any pending messages with the ID 2 (which is used to indicate that the activity has been paused due to a configuration change), and if there are, it removes them and calls the `onResumeFragments` method, which is used to re-start any fragments that were stopped due to the configuration change. Finally, it dispatches the `onPause` event to all fragments in the activity.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onPictureInPictureModeChanged(boolean)', 'code': 'void  onPictureInPictureModeChanged(boolean)  {\n        this.mFragments.dispatchPictureInPictureModeChanged(isInPictureInPictureMode);\n    }', 'summary': " It's designed to dispatch a callback to the Activity or Fragment that's currently in picture-in-picture mode, which is then responsible for reacting to the change. The provided code is a no-op, which will do nothing when the callback is dispatched.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onPostResume()', 'code': 'void  onPostResume()  {\n        super.onPostResume();\n        this.mHandler.removeMessages(2);\n        onResumeFragments();\n        this.mFragments.execPendingActions();\n    }', 'summary': ' It appears to register a `onPostResume` callback with the Activity, which is then called when the Activity is resumed after being paused. The code then removes any pending messages with ID 2 from the handler, which are used to indicate that the Activity is in the background. After that, it calls the `onResumeFragments` method, which is supposed to handle any pending Fragment transactions. Finally, it executes any pending actions on the Fragment Manager, which are used to update the UI after a configuration change.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'boolean onPreparePanel(int,android.view.View,android.view.Menu)', 'code': 'boolean  onPreparePanel(int,android.view.View,android.view.Menu)  {\n        if (featureId == 0 && menu != null) {\n            boolean goforit = onPrepareOptionsPanel(view, menu);\n            return goforit | this.mFragments.dispatchPrepareOptionsMenu(menu);\n        }\n        boolean goforit2 = super.onPreparePanel(featureId, view, menu);\n        return goforit2;\n    }', 'summary': " It appears to be a method override in an Activity class. The method is called when the Activity is ready to show a context menu for a particular view (typically a ViewPager). The method first checks if the provided feature ID is 0, indicating that the context menu is being shown for the ViewPager. If this is true, it then checks if the provided menu is not null. If this is true, it then calls the method onPrepareOptionsPanel() and stores the result in a boolean variable 'goforit'. It then dispatches the menu preparation to the child Fragments using the FragmentManager, and stores the result in a second boolean variable 'goforit2'. The final result is the OR of the two boolean variables, which is then returned.\n\nThe provided code is designed to ensure that the child Fragments receive the menu preparation, even if the Activity's onPreparePanel() method returns false. This is necessary because the ViewPager does not call onPreparePanel() on its own, and therefore the child Fragments do not receive the menu preparation.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onRequestPermissionsResult(int,java.lang.String[],int[])', 'code': 'void  onRequestPermissionsResult(int,java.lang.String[],int[])  {\n        this.mFragments.noteStateNotSaved();\n        int index = (requestCode >> 16) & SupportMenu.USER_MASK;\n        if (index != 0) {\n            int index2 = index - 1;\n            String who = this.mPendingFragmentActivityResults.get(index2);\n            this.mPendingFragmentActivityResults.remove(index2);\n            if (who == null) {\n                Log.w(TAG, "Activity result delivered for unknown Fragment.");\n                return;\n            }\n            Fragment frag = this.mFragments.findFragmentByWho(who);\n            if (frag == null) {\n                Log.w(TAG, "Activity result no fragment exists for who: " + who);\n            } else {\n                frag.onRequestPermissionsResult(requestCode & SupportMenu.USER_MASK, permissions, grantResults);\n            }\n        }\n    }', 'summary': " It is converting the value of 'None' to a string 'None'. This is useful when you want to print the value of an optional variable without having to check if it is not None beforehand.  It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list.", 'children': {'java.lang.String toString()': " It converts the value of 'None' to a string 'None'. This is useful when you want to print the value of an optional variable without having to check if it is not None beforehand.", 'java.lang.StringBuilder append(java.lang.String)': " It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list."}}
Entry point data children: {'java.lang.String toString()': " It converts the value of 'None' to a string 'None'. This is useful when you want to print the value of an optional variable without having to check if it is not None beforehand.", 'java.lang.StringBuilder append(java.lang.String)': " It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list."}
Child function name: java.lang.String toString()
Child summary:  It converts the value of 'None' to a string 'None'. This is useful when you want to print the value of an optional variable without having to check if it is not None beforehand.
Child function name: java.lang.StringBuilder append(java.lang.String)
Child summary:  It is appending 'None' to the list 'numbers'. Since 'numbers' is a list, 'None' is a valid value and will be added to the end of the list.
Entry point data: {'entry_point name': 'void onResume()', 'code': 'void  onResume()  {\n        super.onResume();\n        this.mHandler.sendEmptyMessage(2);\n        this.mResumed = true;\n        this.mFragments.execPendingActions();\n    }', 'summary': " It appears to register a new message (with ID 2) on the main thread's message queue, which will then be processed in the `handleMessage` method of the `FragmentActivity` class. The `onResume` method is called when the activity is resumed, which is typically when the user switches back to the app after it has been put in the background. The code then sets a flag indicating that the activity has been resumed, and finally calls the `execPendingActions` method of the `FragmentManager` to execute any pending actions that were added to the queue while the activity was paused.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onSaveInstanceState(android.os.Bundle)', 'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        super.onSaveInstanceState(outState);\n        markFragmentsCreated();\n        Parcelable p = this.mFragments.saveAllState();\n        if (p != null) {\n            outState.putParcelable(FRAGMENTS_TAG, p);\n        }\n        if (this.mPendingFragmentActivityResults.size() > 0) {\n            outState.putInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG, this.mNextCandidateRequestIndex);\n            int[] requestCodes = new int[this.mPendingFragmentActivityResults.size()];\n            String[] fragmentWhos = new String[this.mPendingFragmentActivityResults.size()];\n            for (int i = 0; i < this.mPendingFragmentActivityResults.size(); i++) {\n                requestCodes[i] = this.mPendingFragmentActivityResults.keyAt(i);\n                fragmentWhos[i] = this.mPendingFragmentActivityResults.valueAt(i);\n            }\n            outState.putIntArray(ALLOCATED_REQUEST_INDICIES_TAG, requestCodes);\n            outState.putStringArray(REQUEST_FRAGMENT_WHO_TAG, fragmentWhos);\n        }\n    }', 'summary': " It first calls the superclass' `onSaveInstanceState()` method with the provided `Bundle` object, then it marks the fragments as created, and finally it saves the fragment states in a `Parcelable` object. If there are any pending fragment activity results, it adds the request indices, request codes, and fragment owners to the `Bundle`.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onStart()', 'code': 'void  onStart()  {\n        super.onStart();\n        this.mStopped = false;\n        if (!this.mCreated) {\n            this.mCreated = true;\n            this.mFragments.dispatchActivityCreated();\n        }\n        this.mFragments.noteStateNotSaved();\n        this.mFragments.execPendingActions();\n        this.mFragments.dispatchStart();\n    }', 'summary': " It creates a new activity and starts it. It first calls the `super.onStart()` method, which is then followed by some code that initializes the activity's state and starts the fragments in the activity. The `super.onStart()` method is necessary in every Activity, and it initializes the activity's state. In this case, it initializes the `mStopped` field to `false`. The `mCreated` field is also initialized to `true`, indicating that the activity has been created. The `mFragments.dispatchActivityCreated()` method is then called, which in turn calls the `onActivityCreated()` method in all fragments attached to the activity. The `mFragments.noteStateNotSaved()` method is called to indicate that the activity's state has not been saved. The `mFragments.execPendingActions()` method is then called, which ensures that any pending actions, such as `onAttach()` or `onCreateView()` have been executed. Finally, the `mFragments.dispatchStart()` method is called, which in turn calls the `onStart()` method in all fragments attached to the activity.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onStateNotSaved()', 'code': 'void  onStateNotSaved()  {\n        this.mFragments.noteStateNotSaved();\n    }', 'summary': ' It appears to register a callback with the `FragmentManager` that will be invoked when the `FragmentTransaction` is committed and its state is not saved. The callback is defined in the `Fragment` class and is called `onStateNotSaved`. The `FragmentManager` is provided by the `Activity` that is hosting the `Fragment`. The provided code simply calls this method on the `FragmentManager`.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onStop()', 'code': 'void  onStop()  {\n        super.onStop();\n        this.mStopped = true;\n        markFragmentsCreated();\n        this.mFragments.dispatchStop();\n    }', 'summary': " It creates a new method called 'onStop' in the Activity class. This method is called when the Activity is stopped. It first calls the 'onStop' method in the parent class (Activity), which is used to perform any necessary cleanup. Then, it sets a flag'mStopped' to true, which is used to prevent the Activity from performing any further actions when it is stopped. Finally, it marks the Activity's Fragments as created, which ensures that they are not destroyed when the Activity is stopped.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void startActivityForResult(android.content.Intent,int)', 'code': 'void  startActivityForResult(android.content.Intent,int)  {\n        if (!this.mStartedActivityFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startActivityForResult(intent, requestCode);\n    }', 'summary': ' It appears to be a method override for the startActivityForResult method in an Activity class. The method is overridden to check for a valid request code before starting the activity. However, the provided code does not actually check for a valid request code. The code simply calls the superclass method with the provided request code without performing any checks. This could potentially cause an exception if the provided request code is invalid.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void startActivityForResult(android.content.Intent,int,android.os.Bundle)', 'code': 'void  startActivityForResult(android.content.Intent,int,android.os.Bundle)  {\n        if (!this.mStartedActivityFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startActivityForResult(intent, requestCode);\n    }', 'summary': ' It appears to be a method override for the startActivityForResult method in an Activity class. The method is overridden to check for a valid request code before starting the activity. However, the provided code does not actually check for a valid request code. The code simply calls the superclass method without performing any checks. This can potentially cause a crash if an invalid request code is provided.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)', 'code': 'void  startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)  {\n        if (!this.mStartedIntentSenderFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);\n    }', 'summary': " It appears to be a method that is used to start an intent sender from an activity or fragment. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.\n\nExplanation:\n1. The method'startIntentSenderForResult' is defined in the 'android.app.Activity' class.\n2. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.\n3. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input.\n4. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.\n5. The superclass method'startIntentSenderForResult' is defined in the 'android.app.Fragment' class.\n6. It takes an intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.\n7. It first checks if the request code is valid (i.e., not equal to -1). If the request code is not valid, it calls the method 'checkForValidRequestCode' with the provided request code as input.\n8. After that, it calls the superclass method'startIntentSenderForResult' with the provided intent sender, request code, intent, flags mask, flags values, and extra flags as input parameters.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)', 'code': 'void  startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)  {\n        if (!this.mStartedIntentSenderFromFragment && requestCode != -1) {\n            checkForValidRequestCode(requestCode);\n        }\n        super.startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);\n    }', 'summary': " It's not clear from the code itself what it does. It appears to be a method that is overriding a method in the Activity class. The method is called'startIntentSenderForResult', and it takes an IntentSender, requestCode, Intent, flagsMask, flagsValues, and extraFlags as input parameters. It checks if the Activity is not started from a Fragment, and if the requestCode is not -1, it checks if the requestCode is valid using the 'checkForValidRequestCode' method. After that, it calls the'super.startIntentSenderForResult' method with the provided input parameters.", 'children': {'void checkForValidRequestCode(int)': ' It checks if the requestCode is a valid 16-bit unsigned integer (i.e., it is in the range 0 to 65535). If the requestCode is not valid, it throws an IllegalArgumentException with the message "Can only use lower 16 bits for requestCode".', 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'void checkForValidRequestCode(int)': ' It checks if the requestCode is a valid 16-bit unsigned integer (i.e., it is in the range 0 to 65535). If the requestCode is not valid, it throws an IllegalArgumentException with the message "Can only use lower 16 bits for requestCode".', 'None': 'No children functions found, no summary generated.'}
Child function name: void checkForValidRequestCode(int)
Child summary:  It checks if the requestCode is a valid 16-bit unsigned integer (i.e., it is in the range 0 to 65535). If the requestCode is not valid, it throws an IllegalArgumentException with the message "Can only use lower 16 bits for requestCode".
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'boolean dispatchKeyEvent(android.view.KeyEvent)', 'code': 'boolean  dispatchKeyEvent(android.view.KeyEvent)  {\n        View decor = getWindow().getDecorView();\n        if (decor == null || !KeyEventDispatcher.dispatchBeforeHierarchy(decor, event)) {\n            return KeyEventDispatcher.dispatchKeyEvent(this, decor, this, event);\n        }\n        return true;\n    }', 'summary': " It's not clear from the code itself what it does. It appears to register an event listener on the decor view of the current window, and then dispatch the event to the registered listener. However, it's not clear what the listener is doing or why it's registered on the decor view.", 'children': {'boolean dispatchKeyEvent(androidx.core.view.KeyEventDispatcher$Component,android.view.View,android.view.Window$Callback,android.view.KeyEvent)': " It appears to be a method that dispatches key events to a component, which is used by Android's View hierarchy. The code checks for a null component and returns false if one is found. Then, it checks the SDK version and, if it's 28 or higher, it directly calls the component's superDispatchKeyEvent method and returns its result. If the SDK version is lower than 28, it checks the type of the callback (activity or dialog) and, based on that, calls the corresponding superDispatchKeyEvent method. If the callback is null, it returns false. Finally, if the root view is not null, it calls ViewCompat.dispatchUnhandledKeyEventBeforeCallback with the root view and the event. If this returns true, it means that the event was not handled by the component and the app should continue to handle it. If it returns false, it means that the event was handled by the component and the app should not continue to handle it.", 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'boolean dispatchKeyEvent(androidx.core.view.KeyEventDispatcher$Component,android.view.View,android.view.Window$Callback,android.view.KeyEvent)': " It appears to be a method that dispatches key events to a component, which is used by Android's View hierarchy. The code checks for a null component and returns false if one is found. Then, it checks the SDK version and, if it's 28 or higher, it directly calls the component's superDispatchKeyEvent method and returns its result. If the SDK version is lower than 28, it checks the type of the callback (activity or dialog) and, based on that, calls the corresponding superDispatchKeyEvent method. If the callback is null, it returns false. Finally, if the root view is not null, it calls ViewCompat.dispatchUnhandledKeyEventBeforeCallback with the root view and the event. If this returns true, it means that the event was not handled by the component and the app should continue to handle it. If it returns false, it means that the event was handled by the component and the app should not continue to handle it.", 'None': 'No children functions found, no summary generated.'}
Child function name: boolean dispatchKeyEvent(androidx.core.view.KeyEventDispatcher$Component,android.view.View,android.view.Window$Callback,android.view.KeyEvent)
Child summary:  It appears to be a method that dispatches key events to a component, which is used by Android's View hierarchy. The code checks for a null component and returns false if one is found. Then, it checks the SDK version and, if it's 28 or higher, it directly calls the component's superDispatchKeyEvent method and returns its result. If the SDK version is lower than 28, it checks the type of the callback (activity or dialog) and, based on that, calls the corresponding superDispatchKeyEvent method. If the callback is null, it returns false. Finally, if the root view is not null, it calls ViewCompat.dispatchUnhandledKeyEventBeforeCallback with the root view and the event. If this returns true, it means that the event was not handled by the component and the app should continue to handle it. If it returns false, it means that the event was handled by the component and the app should not continue to handle it.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'boolean dispatchKeyShortcutEvent(android.view.KeyEvent)', 'code': 'boolean  dispatchKeyShortcutEvent(android.view.KeyEvent)  {\n        View decor = getWindow().getDecorView();\n        if (decor == null || !KeyEventDispatcher.dispatchBeforeHierarchy(decor, event)) {\n            return super.dispatchKeyShortcutEvent(event);\n        }\n        return true;\n    }', 'summary': " It's a method override in an Android Activity class. The method is called when the user presses a key while the activity is in focus. The method first checks if the decor view is null, which can happen if the activity is not yet fully initialized. If that's the case, the method returns false to indicate that the key shortcut event was not handled. Otherwise, it uses the KeyEventDispatcher class to dispatch the key shortcut event to the view hierarchy before the activity's own key shortcut handling. If the KeyEventDispatcher returns false, the activity's key shortcut handling will also be performed.", 'children': {'boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent)': " It's not clear from the code itself what it does. It appears to be a method that dispatches an unhandled key event to the view hierarchy before the hierarchy itself handles the event. The method is called from a ViewGroup's dispatchKeyEvent method. The method returns true if the event was handled by the view hierarchy, and false otherwise.", 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent)': " It's not clear from the code itself what it does. It appears to be a method that dispatches an unhandled key event to the view hierarchy before the hierarchy itself handles the event. The method is called from a ViewGroup's dispatchKeyEvent method. The method returns true if the event was handled by the view hierarchy, and false otherwise.", 'None': 'No children functions found, no summary generated.'}
Child function name: boolean dispatchBeforeHierarchy(android.view.View,android.view.KeyEvent)
Child summary:  It's not clear from the code itself what it does. It appears to be a method that dispatches an unhandled key event to the view hierarchy before the hierarchy itself handles the event. The method is called from a ViewGroup's dispatchKeyEvent method. The method returns true if the event was handled by the view hierarchy, and false otherwise.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n    }', 'summary': " It's not clear from the code itself what it does. It appears to register a ReportFragment for the Activity, which is needed for the Fragment to work properly.", 'children': {'void injectIfNeededIn(android.app.Activity)': ' It first retrieves the FragmentManager from the Activity using `activity.getFragmentManager()`. Then, it checks if there is already a fragment with the tag `REPORT_FRAGMENT_TAG`. If there is not, it adds a new `ReportFragment()` and commits the transaction using `manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit()`. Finally, it executes any pending transactions using `manager.executePendingTransactions()`.\n\nThe provided code is designed to ensure that the `ReportFragment` is only added to the Activity once, even if the Activity is recreated due to a configuration change. This is achieved by checking for the presence of the `ReportFragment` before adding it, and by using the `executePendingTransactions()` method to ensure that the FragmentTransaction is applied immediately.', 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'void injectIfNeededIn(android.app.Activity)': ' It first retrieves the FragmentManager from the Activity using `activity.getFragmentManager()`. Then, it checks if there is already a fragment with the tag `REPORT_FRAGMENT_TAG`. If there is not, it adds a new `ReportFragment()` and commits the transaction using `manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit()`. Finally, it executes any pending transactions using `manager.executePendingTransactions()`.\n\nThe provided code is designed to ensure that the `ReportFragment` is only added to the Activity once, even if the Activity is recreated due to a configuration change. This is achieved by checking for the presence of the `ReportFragment` before adding it, and by using the `executePendingTransactions()` method to ensure that the FragmentTransaction is applied immediately.', 'None': 'No children functions found, no summary generated.'}
Child function name: void injectIfNeededIn(android.app.Activity)
Child summary:  It first retrieves the FragmentManager from the Activity using `activity.getFragmentManager()`. Then, it checks if there is already a fragment with the tag `REPORT_FRAGMENT_TAG`. If there is not, it adds a new `ReportFragment()` and commits the transaction using `manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit()`. Finally, it executes any pending transactions using `manager.executePendingTransactions()`.

The provided code is designed to ensure that the `ReportFragment` is only added to the Activity once, even if the Activity is recreated due to a configuration change. This is achieved by checking for the presence of the `ReportFragment` before adding it, and by using the `executePendingTransactions()` method to ensure that the FragmentTransaction is applied immediately.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'void onSaveInstanceState(android.os.Bundle)', 'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        this.mLifecycleRegistry.markState(Lifecycle.State.CREATED);\n        super.onSaveInstanceState(outState);\n    }', 'summary': ' It is used to mark the current state of the LifecycleOwner (in this case the Activity) as CREATED. This is necessary because the default state of a LifecycleOwner is DESTROYED, and the Activity will only be in the CREATED state if it is created for the first time (e.g., after a configuration change).', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onBackPressed()', 'code': 'void  onBackPressed()  {\n        if (this.message != null) {\n            this.message.isVisible = false;\n            this.message.viewed();\n        }\n        finish();\n        overridePendingTransition(0, 0);\n    }', 'summary': ' It appears to create a new activity and override the default transition animation. The new activity is created by calling `finish()` and `overridePendingTransition(0, 0)`. The `finish()` method finishes the current activity, and the `overridePendingTransition(0, 0)` method overrides the default transition animation.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState != null) {\n            this.message = restoreFromSavedState(savedInstanceState);\n            Messages.setCurrentMessageFullscreen(this.message);\n        } else {\n            this.message = Messages.getCurrentFullscreenMessage();\n        }\n        if (messageIsValid()) {\n            this.message.messageFullScreenActivity = this;\n            requestWindowFeature(1);\n            RelativeLayout relativeLayout = new RelativeLayout(this);\n            setContentView(relativeLayout);\n        }\n    }', 'summary': ' It declares a MessageFullScreen object and initializes it with the value of the _messageFullScreen field. Then, it synchronizes on the _messageFullScreenMutex and copies the value of the _messageFullScreen field into the messageFullScreen object. Finally, it returns the messageFullScreen object.', 'children': {'void setCurrentMessageFullscreen(com.adobe.mobile.MessageFullScreen)': ' It is a Java method that sets the current message to be displayed in fullscreen mode. It first synchronizes on a mutex, then sets the message to be displayed in fullscreen mode, and finally releases the mutex.', 'com.adobe.mobile.MessageFullScreen getCurrentFullscreenMessage()': ' It first declares a MessageFullScreen object and initializes it with the value of the _messageFullScreen field. Then, it synchronizes on the _messageFullScreenMutex and copies the value of the _messageFullScreen field into the messageFullScreen object. Finally, it returns the messageFullScreen object.\n\nThe provided code is designed to provide thread safety when accessing the _messageFullScreen field. It ensures that multiple threads do not access the field simultaneously, preventing potential conflicts or race conditions when multiple threads try to modify the field.'}}
Entry point data children: {'void setCurrentMessageFullscreen(com.adobe.mobile.MessageFullScreen)': ' It is a Java method that sets the current message to be displayed in fullscreen mode. It first synchronizes on a mutex, then sets the message to be displayed in fullscreen mode, and finally releases the mutex.', 'com.adobe.mobile.MessageFullScreen getCurrentFullscreenMessage()': ' It first declares a MessageFullScreen object and initializes it with the value of the _messageFullScreen field. Then, it synchronizes on the _messageFullScreenMutex and copies the value of the _messageFullScreen field into the messageFullScreen object. Finally, it returns the messageFullScreen object.\n\nThe provided code is designed to provide thread safety when accessing the _messageFullScreen field. It ensures that multiple threads do not access the field simultaneously, preventing potential conflicts or race conditions when multiple threads try to modify the field.'}
Child function name: void setCurrentMessageFullscreen(com.adobe.mobile.MessageFullScreen)
Child summary:  It is a Java method that sets the current message to be displayed in fullscreen mode. It first synchronizes on a mutex, then sets the message to be displayed in fullscreen mode, and finally releases the mutex.
Child function name: com.adobe.mobile.MessageFullScreen getCurrentFullscreenMessage()
Child summary:  It first declares a MessageFullScreen object and initializes it with the value of the _messageFullScreen field. Then, it synchronizes on the _messageFullScreenMutex and copies the value of the _messageFullScreen field into the messageFullScreen object. Finally, it returns the messageFullScreen object.

The provided code is designed to provide thread safety when accessing the _messageFullScreen field. It ensures that multiple threads do not access the field simultaneously, preventing potential conflicts or race conditions when multiple threads try to modify the field.
Entry point data: {'entry_point name': 'void onResume()', 'code': 'void  onResume()  {\n        super.onResume();\n        if (messageIsValid()) {\n            try {\n                final ViewGroup rootViewGroup = (ViewGroup) findViewById(16908290);\n                if (rootViewGroup == null) {\n                    StaticMethods.logErrorFormat("Messages - unable to get root view group from os", new Object[0]);\n                    finish();\n                    overridePendingTransition(0, 0);\n                } else {\n                    rootViewGroup.post(new Runnable() { // from class: com.adobe.mobile.MessageFullScreenActivity.1\n                        @Override // java.lang.Runnable\n                        public void run() {\n                            MessageFullScreenActivity.this.message.rootViewGroup = rootViewGroup;\n                            MessageFullScreenActivity.this.message.showInRootViewGroup();\n                        }\n                    });\n                }\n            } catch (NullPointerException ex) {\n                StaticMethods.logWarningFormat("Messages - content view is in undefined state (%s)", ex.getMessage());\n                finish();\n                overridePendingTransition(0, 0);\n            }\n        }\n    }', 'summary': " It first initializes a 'ViewGroup' variable 'rootViewGroup' with the 'findViewById' method. It then checks if the 'rootViewGroup' variable is null, and if so, it logs an error message. If the 'rootViewGroup' variable is not null, it posts a 'Runnable' object to the 'rootViewGroup' to show the message in the root view group.", 'children': {'java.lang.String getMessage()': ' It is a simple Python function that defines a message that can be used when a user tries to access a non-existent attribute of an object. The function takes a single argument (the name of the attribute that was accessed), and returns a string message indicating that the attribute does not exist.\n\ndef getMessage(attr):\n    return f"The attribute \'{attr}\' does not exist."', 'void run()': " It is a simple Python script that defines a function called 'run' that takes a parameter called 'None'. The function does not do anything with the provided 'None' parameter and simply returns 'None'.", 'void logErrorFormat(java.lang.String,java.lang.Object[])': " It is a Java method that takes a format string and an array of arguments. It then logs the formatted string to the 'ADBMobile' log tag. The method checks if the array of arguments is null or has a length of 0, and if so, it logs the unformatted string to the 'ADBMobile' log tag.", 'void logWarningFormat(java.lang.String,java.lang.Object[])': ' It is a Java method that takes a format string and an array of arguments. It first checks if debug logging is enabled, and if so, it logs the formatted string using the provided arguments. If debug logging is not enabled, it only logs the format string.'}}
Entry point data children: {'java.lang.String getMessage()': ' It is a simple Python function that defines a message that can be used when a user tries to access a non-existent attribute of an object. The function takes a single argument (the name of the attribute that was accessed), and returns a string message indicating that the attribute does not exist.\n\ndef getMessage(attr):\n    return f"The attribute \'{attr}\' does not exist."', 'void run()': " It is a simple Python script that defines a function called 'run' that takes a parameter called 'None'. The function does not do anything with the provided 'None' parameter and simply returns 'None'.", 'void logErrorFormat(java.lang.String,java.lang.Object[])': " It is a Java method that takes a format string and an array of arguments. It then logs the formatted string to the 'ADBMobile' log tag. The method checks if the array of arguments is null or has a length of 0, and if so, it logs the unformatted string to the 'ADBMobile' log tag.", 'void logWarningFormat(java.lang.String,java.lang.Object[])': ' It is a Java method that takes a format string and an array of arguments. It first checks if debug logging is enabled, and if so, it logs the formatted string using the provided arguments. If debug logging is not enabled, it only logs the format string.'}
Child function name: java.lang.String getMessage()
Child summary:  It is a simple Python function that defines a message that can be used when a user tries to access a non-existent attribute of an object. The function takes a single argument (the name of the attribute that was accessed), and returns a string message indicating that the attribute does not exist.

def getMessage(attr):
    return f"The attribute '{attr}' does not exist."
Child function name: void run()
Child summary:  It is a simple Python script that defines a function called 'run' that takes a parameter called 'None'. The function does not do anything with the provided 'None' parameter and simply returns 'None'.
Child function name: void logErrorFormat(java.lang.String,java.lang.Object[])
Child summary:  It is a Java method that takes a format string and an array of arguments. It then logs the formatted string to the 'ADBMobile' log tag. The method checks if the array of arguments is null or has a length of 0, and if so, it logs the unformatted string to the 'ADBMobile' log tag.
Child function name: void logWarningFormat(java.lang.String,java.lang.Object[])
Child summary:  It is a Java method that takes a format string and an array of arguments. It first checks if debug logging is enabled, and if so, it logs the formatted string using the provided arguments. If debug logging is not enabled, it only logs the format string.
Entry point data: {'entry_point name': 'void onSaveInstanceState(android.os.Bundle)', 'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        outState.putString(MESSAGE_STATE_MESSAGE_ID, this.message.messageId);\n        outState.putString(MESSAGE_STATE_REPLACED_HTML, this.message.replacedHtml);\n        super.onSaveInstanceState(outState);\n    }', 'summary': ' It saves the current message ID and replaced HTML in the instance state bundle, which can then be used to restore the message ID and replaced HTML when the activity is recreated.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(savedInstanceState);\n        Config.setContext(getApplicationContext());\n    }', 'summary': ' It creates a new instance of the Config class and sets the context to the current application context. The Config class is a utility class that is used to store global application-wide properties.', 'children': {'void setContext(android.content.Context)': " It sets the context of the current application to 'ApplicationType.APPLICATION_TYPE_HANDHELD'. This context can be used to determine the behavior of the application in different scenarios, e.g., when it is used in a mobile app or in a desktop app.", 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'void setContext(android.content.Context)': " It sets the context of the current application to 'ApplicationType.APPLICATION_TYPE_HANDHELD'. This context can be used to determine the behavior of the application in different scenarios, e.g., when it is used in a mobile app or in a desktop app.", 'None': 'No children functions found, no summary generated.'}
Child function name: void setContext(android.content.Context)
Child summary:  It sets the context of the current application to 'ApplicationType.APPLICATION_TYPE_HANDHELD'. This context can be used to determine the behavior of the application in different scenarios, e.g., when it is used in a mobile app or in a desktop app.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'void onPause()', 'code': 'void  onPause()  {\n        super.onPause();\n        Config.pauseCollectingLifecycleData();\n    }', 'summary': ' It pauses the collection of lifecycle data in the Config class, which is used by the AppLovin SDK to track session and event data.', 'children': {'void pauseCollectingLifecycleData()': ' It first checks if the app is running on a wearable device, and if so, it logs a warning message. Otherwise, it stops the lifecycle data collection by calling the `stop` method on the `Lifecycle` class.', 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'void pauseCollectingLifecycleData()': ' It first checks if the app is running on a wearable device, and if so, it logs a warning message. Otherwise, it stops the lifecycle data collection by calling the `stop` method on the `Lifecycle` class.', 'None': 'No children functions found, no summary generated.'}
Child function name: void pauseCollectingLifecycleData()
Child summary:  It first checks if the app is running on a wearable device, and if so, it logs a warning message. Otherwise, it stops the lifecycle data collection by calling the `stop` method on the `Lifecycle` class.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'void onResume()', 'code': 'void  onResume()  {\n        super.onResume();\n        Config.collectLifecycleData(this);\n    }', 'summary': ' It collects lifecycle data by calling the Config.collectLifecycleData(this) method. The Config class is a custom class that is used to store application-wide configuration settings.', 'children': {'void collectLifecycleData(android.app.Activity)': ' It first checks if the app is running on a wearable device, and if not, it starts the lifecycle tracking using the `Lifecycle.start` method. The `Lifecycle.start` method is provided by the Adobe Mobile SDK, and it is used to start the lifecycle tracking for non-wearable apps. The provided code uses a `Runnable` object to execute the `Lifecycle.start` method on a separate thread, which ensures that the main thread is not blocked while the lifecycle tracking is started.', 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'void collectLifecycleData(android.app.Activity)': ' It first checks if the app is running on a wearable device, and if not, it starts the lifecycle tracking using the `Lifecycle.start` method. The `Lifecycle.start` method is provided by the Adobe Mobile SDK, and it is used to start the lifecycle tracking for non-wearable apps. The provided code uses a `Runnable` object to execute the `Lifecycle.start` method on a separate thread, which ensures that the main thread is not blocked while the lifecycle tracking is started.', 'None': 'No children functions found, no summary generated.'}
Child function name: void collectLifecycleData(android.app.Activity)
Child summary:  It first checks if the app is running on a wearable device, and if not, it starts the lifecycle tracking using the `Lifecycle.start` method. The `Lifecycle.start` method is provided by the Adobe Mobile SDK, and it is used to start the lifecycle tracking for non-wearable apps. The provided code uses a `Runnable` object to execute the `Lifecycle.start` method on a separate thread, which ensures that the main thread is not blocked while the lifecycle tracking is started.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'void onActivityResult(int,int,android.content.Intent)', 'code': 'void  onActivityResult(int,int,android.content.Intent)  {\n        super.onActivityResult(i, i2, intent);\n        if (i == 1) {\n            boolean booleanExtra = getIntent().getBooleanExtra("notify_manager", true);\n            this.zabp = 0;\n            setResult(i2, intent);\n            if (booleanExtra) {\n                GoogleApiManager zab = GoogleApiManager.zab(this);\n                switch (i2) {\n                    case -1:\n                        zab.zao();\n                        break;\n                    case 0:\n                        zab.zaa(new ConnectionResult(13, null), getIntent().getIntExtra("failing_client_id", -1));\n                        break;\n                }\n            }\n        } else if (i == 2) {\n            this.zabp = 0;\n            setResult(i2, intent);\n        }\n        finish();\n    }', 'summary': " It first checks if the request code is 1. If it is, it extracts a boolean value from the intent using the 'getBooleanExtra' method. If this value is true, it initializes a new `GoogleApiManager` object using the 'zab' function and then checks the result code. If the result code is -1, it calls the 'zao' function on the `GoogleApiManager` object to start the resolution process. If the result code is 0, it calls the 'zaa' function with a `ConnectionResult` object containing an error code of 13 and a null error message. The 'failing_client_id' extra is used to identify the ID of the client that failed to connect.", 'children': {'void zao()': " It declares a class called 'Zao' that extends the 'Handler' class. It then overrides the 'handleMessage' method and sends a message with ID 3 to the handler using the 'obtainMessage' method. The 'obtainMessage' method is inherited from the 'Handler' class and is used to create a new message. The message ID is used to identify the type of message that is being sent. In this case, the message is a notification message, which is used to notify the user that something has happened.", 'void zaa(com.google.android.gms.common.ConnectionResult,int)': ' It appears to create a new instance of GoogleApiManager and call its constructor with the provided parameters. It then calls the zabr() method, which is not defined in the class.', 'com.google.android.gms.common.api.internal.GoogleApiManager zab(android.content.Context)': ' It first initializes a `GoogleApiManager` object with the `GoogleApiAvailability` instance. Then, it checks if the `zaic` object is null, and if so, it creates a new `HandlerThread` with the name "GoogleApiHandler" and priority 9. After that, it starts the `HandlerThread`. After that, it creates a new `GoogleApiManager` object with the `context.getApplicationContext()` and the `handlerThread.getLooper()`. Finally, it returns the `GoogleApiManager` object.\n\nThe provided code is not thread-safe, because it creates a new `GoogleApiManager` object each time the method is called. To make the code thread-safe, you can use the following code:\n\n  zab  {\n        GoogleApiManager googleApiManager;\n        synchronized (lock) {\n            if (zaic == null) {\n                HandlerThread handlerThread = new HandlerThread("GoogleApiHandler", 9);\n                handlerThread.start();\n                zaic = new GoogleApiManager(context.getApplicationContext(), handlerThread.getLooper(), GoogleApiAvailability.getInstance());\n            }\n            googleApiManager = zaic;\n        }\n        return googleApiManager;\n    }'}}
Entry point data children: {'void zao()': " It declares a class called 'Zao' that extends the 'Handler' class. It then overrides the 'handleMessage' method and sends a message with ID 3 to the handler using the 'obtainMessage' method. The 'obtainMessage' method is inherited from the 'Handler' class and is used to create a new message. The message ID is used to identify the type of message that is being sent. In this case, the message is a notification message, which is used to notify the user that something has happened.", 'void zaa(com.google.android.gms.common.ConnectionResult,int)': ' It appears to create a new instance of GoogleApiManager and call its constructor with the provided parameters. It then calls the zabr() method, which is not defined in the class.', 'com.google.android.gms.common.api.internal.GoogleApiManager zab(android.content.Context)': ' It first initializes a `GoogleApiManager` object with the `GoogleApiAvailability` instance. Then, it checks if the `zaic` object is null, and if so, it creates a new `HandlerThread` with the name "GoogleApiHandler" and priority 9. After that, it starts the `HandlerThread`. After that, it creates a new `GoogleApiManager` object with the `context.getApplicationContext()` and the `handlerThread.getLooper()`. Finally, it returns the `GoogleApiManager` object.\n\nThe provided code is not thread-safe, because it creates a new `GoogleApiManager` object each time the method is called. To make the code thread-safe, you can use the following code:\n\n  zab  {\n        GoogleApiManager googleApiManager;\n        synchronized (lock) {\n            if (zaic == null) {\n                HandlerThread handlerThread = new HandlerThread("GoogleApiHandler", 9);\n                handlerThread.start();\n                zaic = new GoogleApiManager(context.getApplicationContext(), handlerThread.getLooper(), GoogleApiAvailability.getInstance());\n            }\n            googleApiManager = zaic;\n        }\n        return googleApiManager;\n    }'}
Child function name: void zao()
Child summary:  It declares a class called 'Zao' that extends the 'Handler' class. It then overrides the 'handleMessage' method and sends a message with ID 3 to the handler using the 'obtainMessage' method. The 'obtainMessage' method is inherited from the 'Handler' class and is used to create a new message. The message ID is used to identify the type of message that is being sent. In this case, the message is a notification message, which is used to notify the user that something has happened.
Child function name: void zaa(com.google.android.gms.common.ConnectionResult,int)
Child summary:  It appears to create a new instance of GoogleApiManager and call its constructor with the provided parameters. It then calls the zabr() method, which is not defined in the class.
Child function name: com.google.android.gms.common.api.internal.GoogleApiManager zab(android.content.Context)
Child summary:  It first initializes a `GoogleApiManager` object with the `GoogleApiAvailability` instance. Then, it checks if the `zaic` object is null, and if so, it creates a new `HandlerThread` with the name "GoogleApiHandler" and priority 9. After that, it starts the `HandlerThread`. After that, it creates a new `GoogleApiManager` object with the `context.getApplicationContext()` and the `handlerThread.getLooper()`. Finally, it returns the `GoogleApiManager` object.

The provided code is not thread-safe, because it creates a new `GoogleApiManager` object each time the method is called. To make the code thread-safe, you can use the following code:

  zab  {
        GoogleApiManager googleApiManager;
        synchronized (lock) {
            if (zaic == null) {
                HandlerThread handlerThread = new HandlerThread("GoogleApiHandler", 9);
                handlerThread.start();
                zaic = new GoogleApiManager(context.getApplicationContext(), handlerThread.getLooper(), GoogleApiAvailability.getInstance());
            }
            googleApiManager = zaic;
        }
        return googleApiManager;
    }
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        super.onCreate(bundle);\n        if (bundle != null) {\n            this.zabp = bundle.getInt("resolution");\n        }\n        if (this.zabp != 1) {\n            Bundle extras = getIntent().getExtras();\n            if (extras == null) {\n                Log.e("GoogleApiActivity", "Activity started without extras");\n                finish();\n                return;\n            }\n            PendingIntent pendingIntent = (PendingIntent) extras.get("pending_intent");\n            Integer num = (Integer) extras.get("error_code");\n            if (pendingIntent == null && num == null) {\n                Log.e("GoogleApiActivity", "Activity started without resolution");\n                finish();\n            } else if (pendingIntent != null) {\n                try {\n                    startIntentSenderForResult(pendingIntent.getIntentSender(), 1, null, 0, 0, 0);\n                    this.zabp = 1;\n                } catch (IntentSender.SendIntentException e) {\n                    Log.e("GoogleApiActivity", "Failed to launch pendingIntent", e);\n                    finish();\n                }\n            } else {\n                GoogleApiAvailability.getInstance().showErrorDialogFragment(this, num.intValue(), 2, this);\n                this.zabp = 1;\n            }\n        }\n    }', 'summary': " It declares two variables 'zabp' and 'pendingIntent', assigns them default values, and then checks for the presence of extras in the intent. If the extras are not present, it logs an error message and finishes the activity. If the extras are present, it checks for the'resolution' key in the bundle. If the'resolution' key is not present, it logs an error message and finishes the activity. If the'resolution' key is present, it assigns the value of'resolution' to 'zabp' and sets 'pendingIntent' to the value of the 'pending_intent' extra. It then attempts to start the activity using the 'pendingIntent' object, which will either launch the resolution activity or display the error dialog depending on the value of 'zabp'. If the activity fails to launch, it logs an error message and finishes the activity. If the activity is launched successfully, it sets 'zabp' to 1 to indicate that the error dialog was shown successfully.", 'children': {'boolean showErrorDialogFragment(android.app.Activity,int,int,android.content.DialogInterface$OnCancelListener)': ' It is a method that is used to display an error dialog in a fragment. It takes the activity that the fragment is currently attached to, an error message, and two optional listener objects. It returns true if the error dialog was shown successfully, false otherwise.', 'int e(java.lang.String,java.lang.String)': " It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.", 'int e(java.lang.String,java.lang.String,java.lang.Throwable)': " It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.", 'com.google.android.gms.common.GoogleApiAvailability getInstance()': " It declares a Java method called 'getInstance' that returns the 'zaao' object. It is used as a singleton, which ensures that only one instance of the 'zaao' class is created."}}
Entry point data children: {'boolean showErrorDialogFragment(android.app.Activity,int,int,android.content.DialogInterface$OnCancelListener)': ' It is a method that is used to display an error dialog in a fragment. It takes the activity that the fragment is currently attached to, an error message, and two optional listener objects. It returns true if the error dialog was shown successfully, false otherwise.', 'int e(java.lang.String,java.lang.String)': " It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.", 'int e(java.lang.String,java.lang.String,java.lang.Throwable)': " It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.", 'com.google.android.gms.common.GoogleApiAvailability getInstance()': " It declares a Java method called 'getInstance' that returns the 'zaao' object. It is used as a singleton, which ensures that only one instance of the 'zaao' class is created."}
Child function name: boolean showErrorDialogFragment(android.app.Activity,int,int,android.content.DialogInterface$OnCancelListener)
Child summary:  It is a method that is used to display an error dialog in a fragment. It takes the activity that the fragment is currently attached to, an error message, and two optional listener objects. It returns true if the error dialog was shown successfully, false otherwise.
Child function name: int e(java.lang.String,java.lang.String)
Child summary:  It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.
Child function name: int e(java.lang.String,java.lang.String,java.lang.Throwable)
Child summary:  It declares a variable 'e' and assigns it the value 'None'. Then, it prints the value of 'e' to the console, which will be 'None'.
Child function name: com.google.android.gms.common.GoogleApiAvailability getInstance()
Child summary:  It declares a Java method called 'getInstance' that returns the 'zaao' object. It is used as a singleton, which ensures that only one instance of the 'zaao' class is created.
Entry point data: {'entry_point name': 'void onSaveInstanceState(android.os.Bundle)', 'code': 'void  onSaveInstanceState(android.os.Bundle)  {\n        bundle.putInt("resolution", this.zabp);\n        super.onSaveInstanceState(bundle);\n    }', 'summary': " It is saving the current value of the private variable 'zabp' (which represents the current resolution) into the 'bundle' before calling the superclass method. This is necessary because the superclass method will be called when the activity is destroyed, which will happen when the user rotates the device or navigates away from the activity. If the current resolution is not saved, the activity will be restored with the default resolution (1080x1920) which will result in a large amount of screen space being used, which is not ideal.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        Log.w("Unity", "UnityPlayerNativeActivity has been deprecated, please update your AndroidManifest to use UnityPlayerActivity instead");\n        super.onCreate(bundle);\n    }', 'summary': " It's designed to log a warning message in the Android logcat, which is a system log that can be accessed using the 'Logcat' command in the Android Debugging Tools. The message is shown when the deprecated 'UnityPlayerNativeActivity' is used in the AndroidManifest.xml. It's recommened to use the new 'UnityPlayerActivity' instead, which is a subclass of 'UnityPlayerNativeActivity' that has been updated to properly handle the transition to the new Android Activity Lifecycle.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        requestWindowFeature(1);\n        super.onCreate(bundle);\n        getWindow().setFormat(2);\n        this.mUnityPlayer = new CUnityPlayer(this);\n        setContentView(this.mUnityPlayer);\n        this.mUnityPlayer.requestFocus();\n    }', 'summary': ' It appears to set the window format to RGB565, which is a 16-bit color format. However, it does not actually do this. The method `getWindow().setFormat(2);` is a no-op, and the window format will remain unchanged. The correct way to set the window format is to use `getWindow().setFormat(PixelFormat.RGB_565);`, as shown in the following code:\n\nvoid  onCreate(android.os.Bundle)  {\n        requestWindowFeature(1);\n        super.onCreate(bundle);\n        getWindow().setFormat(PixelFormat.RGB_565);\n        this.mUnityPlayer = new CUnityPlayer(this);\n        setContentView(this.mUnityPlayer);\n        this.mUnityPlayer.requestFocus();\n    }', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'boolean dispatchKeyEvent(android.view.KeyEvent)', 'code': 'boolean  dispatchKeyEvent(android.view.KeyEvent)  {\n        return keyEvent.getAction() == 2 ? this.mUnityPlayer.injectEvent(keyEvent) : super.dispatchKeyEvent(keyEvent);\n    }', 'summary': ' It appears to override the dispatchKeyEvent method of the Activity class, which is called when an event is dispatched to the activity. The code checks if the key event is a key up event (ACTION_UP == 2) and, if so, it sends the event to the Unity player using the injectEvent method. If the key event is not a key up event, it is passed to the superclass (calling the original dispatchKeyEvent method) for handling.\n\nThe provided code is designed to work with the Unity player. The injectEvent method is part of the UnityPlayer class, which is a Java interface with a corresponding implementation in the UnityPlayerActivity class. The interface allows the Unity player to pass events to the activity, which handles them appropriately.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onConfigurationChanged(android.content.res.Configuration)', 'code': 'void  onConfigurationChanged(android.content.res.Configuration)  {\n        super.onConfigurationChanged(configuration);\n        this.mUnityPlayer.configurationChanged(configuration);\n    }', 'summary': ' It appears to register a callback with the Android OS that is invoked when the device configuration changes. In the provided code, the callback is invoked by calling the `onConfigurationChanged` method on the `UnityPlayer` instance, which in turn calls the `configurationChanged` method on the `UnityPlayer` Java class. The `configurationChanged` method is a no-op in the base `UnityPlayer` class, but can be overridden by subclasses to provide custom behavior. In this case, the `UnityPlayer` base class is used directly, so the `configurationChanged` method is a no-op. The provided code also uses the `super` keyword, which is a reference to the parent class, in order to invoke the `onConfigurationChanged` method on the parent class. This ensures that the correct method is called for any subclasses that override the `UnityPlayer` class.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        requestWindowFeature(1);\n        super.onCreate(bundle);\n        this.mUnityPlayer = new UnityPlayer(this);\n        setContentView(this.mUnityPlayer);\n        this.mUnityPlayer.requestFocus();\n    }', 'summary': " It's not clear from the code itself what it does. It appears to create a new UnityPlayer instance and set it as the content view of the activity. It also requests focus for the UnityPlayer instance, which is necessary to receive input events from the Unity Player.", 'children': {'boolean requestFocus()': ' It is used to request focus on the specified component, but in this case, the specified component is None, which means that the focus will be requested on the entire window.', 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'boolean requestFocus()': ' It is used to request focus on the specified component, but in this case, the specified component is None, which means that the focus will be requested on the entire window.', 'None': 'No children functions found, no summary generated.'}
Child function name: boolean requestFocus()
Child summary:  It is used to request focus on the specified component, but in this case, the specified component is None, which means that the focus will be requested on the entire window.
Child function name: None
Child summary: No children functions found, no summary generated.
Entry point data: {'entry_point name': 'void onDestroy()', 'code': 'void  onDestroy()  {\n        this.mUnityPlayer.quit();\n        super.onDestroy();\n    }', 'summary': " It's registering an Android lifecycle callback method (onDestroy) that is called when the Activity is destroyed. In the provided code, the method is quitting the Unity player, which is necessary to properly shutdown the Unity environment. Finally, it's calling the superclass' (Activity) onDestroy method, which is necessary to ensure proper cleanup of the Activity.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'boolean onGenericMotionEvent(android.view.MotionEvent)', 'code': 'boolean  onGenericMotionEvent(android.view.MotionEvent)  {\n        return this.mUnityPlayer.injectEvent(motionEvent);\n    }', 'summary': " It's designed to forward Android touch events to the Unity player, which is running the game. The method returns true if the event was handled by the Unity player, and false otherwise.\n\nThe provided code forwards the Android MotionEvent to the Unity player by calling the 'injectEvent' method on the'mUnityPlayer' object. The 'injectEvent' method returns true if the event was handled by the player, and false otherwise.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'boolean onKeyDown(int,android.view.KeyEvent)', 'code': 'boolean  onKeyDown(int,android.view.KeyEvent)  {\n        return this.mUnityPlayer.injectEvent(keyEvent);\n    }', 'summary': ' It appears to register an Android key event listener on the current Activity, which will then forward the key event to the Unity player when it is ready. The function returns true if the key event was handled by the Unity player, and false otherwise.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'boolean onKeyUp(int,android.view.KeyEvent)', 'code': 'boolean  onKeyUp(int,android.view.KeyEvent)  {\n        return this.mUnityPlayer.injectEvent(keyEvent);\n    }', 'summary': ' It appears to register an Android key event listener (onKeyUp) that forwards the key event to the Unity player. The function returns true if the event was handled by the Unity player, otherwise false.\n\nThe provided code is part of a class that extends the UnityPlayerActivity. The class overrides the onKeyUp function to forward key events to the Unity player.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onLowMemory()', 'code': 'void  onLowMemory()  {\n        super.onLowMemory();\n        this.mUnityPlayer.lowMemory();\n    }', 'summary': ' It appears to register an Android activity callback that is called when the app is running low on memory. It then calls the `lowMemory` method on the Unity player object, which is used to free unused resources.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onNewIntent(android.content.Intent)', 'code': 'void  onNewIntent(android.content.Intent)  {\n        setIntent(intent);\n    }', 'summary': " It appears to register an activity lifecycle callback that sets the current activity's intent to the provided intent. The callback is called when the activity is created from a new intent, e.g., when the user clicks on an app icon in the launcher. The provided code is not actually functional and will not affect the behavior of the app.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onPause()', 'code': 'void  onPause()  {\n        super.onPause();\n        this.mUnityPlayer.pause();\n    }', 'summary': ' It pauses the Unity player when the app is paused.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onResume()', 'code': 'void  onResume()  {\n        super.onResume();\n        this.mUnityPlayer.resume();\n    }', 'summary': ' It is registering an activity lifecycle callback method (onResume) that will be invoked when the activity is resumed. In the callback method, it is calling the UnityPlayer (mUnityPlayer) resume method, which will cause the Unity content to be rendered.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onStart()', 'code': 'void  onStart()  {\n        super.onStart();\n        this.mUnityPlayer.start();\n    }', 'summary': ' It starts a new activity in the AndroidManifest.xml file and then initializes the Unity player. The onStart() method is a lifecycle callback that is called when the activity is created. In this case, it is used to start the Unity player.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onStop()', 'code': 'void  onStop()  {\n        super.onStop();\n        this.mUnityPlayer.stop();\n    }', 'summary': ' It is designed to override the `onStop()` method of the `Activity` class, which is called when the activity is about to stop. In this case, it is used to stop the Unity player, which is running in the background.', 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'boolean onTouchEvent(android.view.MotionEvent)', 'code': 'boolean  onTouchEvent(android.view.MotionEvent)  {\n        return this.mUnityPlayer.injectEvent(motionEvent);\n    }', 'summary': " It's designed to forward touch events to the Unity player, which is running the game. The code declares a boolean function 'onTouchEvent' that takes a 'MotionEvent' as an input. It then returns the result of calling the 'injectEvent' function on the Unity player instance, which is provided as a member variable. This means that the function will return true if the event was successfully injected, and false otherwise.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onTrimMemory(int)', 'code': 'void  onTrimMemory(int)  {\n        super.onTrimMemory(i);\n        if (i == 15) {\n            this.mUnityPlayer.lowMemory();\n        }\n    }', 'summary': " It's registering an `onTrimMemory` callback with the Android Activity Manager. The callback is invoked when the system needs to free up memory. The provided code is checking for the `TRIM_MEMORY_RUNNING_LOW` constant, which is used to indicate that the system is running low on memory. If the callback is invoked with this constant, it's instructing the `UnityPlayer` to release unused memory.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onWindowFocusChanged(boolean)', 'code': 'void  onWindowFocusChanged(boolean)  {\n        super.onWindowFocusChanged(z);\n        this.mUnityPlayer.windowFocusChanged(z);\n    }', 'summary': " It's registering an override for the `onWindowFocusChanged` method in the `UnityPlayerActivity` class. The override is calling the superclass implementation of the method and then forwarding the call to the `UnityPlayer` instance, which is used to interact with the Unity Engine. The `windowFocusChanged` method is a part of the `UnityPlayer` class and is used to notify the Unity Engine about the change in the window focus.", 'children': {'None': 'No children functions found, no summary generated.'}}
Entry point data: {'entry_point name': 'void onCreate(android.os.Bundle)', 'code': 'void  onCreate(android.os.Bundle)  {\n        Log.w("Unity", "UnityPlayerProxyActivity has been deprecated, please update your AndroidManifest to use UnityPlayerActivity instead");\n        super.onCreate(bundle);\n    }', 'summary': ' It\'s designed to log a warning message in the Android logcat, which is a system log that can be accessed using \'adb logcat\' command. The message is displayed only once, so it will not be repeated if the app is restarted. The code uses the \'Log.w\' method, which is a static method in the \'Log\' class. The first parameter is the tag, which is used to identify the source of the message. In this case, the tag is \'Unity\'. The second parameter is the message itself.\n\nThe provided code is designed to support the old \'UnityPlayerProxyActivity\' class, which has been deprecated in favor of the new \'UnityPlayerActivity\' class. The new class is more efficient and does not require any additional permissions, so it\'s recommended to use it instead of the old one. The updated code should look like this:\n\nvoid  onCreate(android.os.Bundle)  {\n        Log.w("Unity", "The \'UnityPlayerProxyActivity\' class has been deprecated, please update your AndroidManifest to use the \'UnityPlayerActivity\' class instead.");\n        super.onCreate(bundle);\n    }', 'children': {'int w(java.lang.String,java.lang.String)': " It declares a variable 'w' and assigns it the value 'None'. Then, it prints the value of 'w' to the console, which will be 'None'.", 'None': 'No children functions found, no summary generated.'}}
Entry point data children: {'int w(java.lang.String,java.lang.String)': " It declares a variable 'w' and assigns it the value 'None'. Then, it prints the value of 'w' to the console, which will be 'None'.", 'None': 'No children functions found, no summary generated.'}
Child function name: int w(java.lang.String,java.lang.String)
Child summary:  It declares a variable 'w' and assigns it the value 'None'. Then, it prints the value of 'w' to the console, which will be 'None'.
Child function name: None
Child summary: No children functions found, no summary generated.
Output saved at /scratch/ms9761/rea-llm/starcoder/outputs_text/be_vrt_buck.json!
