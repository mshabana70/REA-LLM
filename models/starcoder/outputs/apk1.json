{
  "Function_1": {
    "code": "public class SafeIterableMap<K, V> implements Iterable<Map.Entry<K, V>> {\n    private Entry<K, V> mEnd;\n    private WeakHashMap<SupportRemove<K, V>, Boolean> mIterators = new WeakHashMap<>();\n    private int mSize = 0;\n    private Entry<K, V> mStart;\n\n    /* JADX INFO: Access modifiers changed from: package-private */\n    /* loaded from: classes.dex */\n    public interface SupportRemove<K, V> {\n        void supportRemove(@NonNull Entry<K, V> entry);\n    }\n\n    protected Entry<K, V> get(K k) {\n        Entry<K, V> entry = this.mStart;\n        while (entry != null && !entry.mKey.equals(k)) {\n            entry = entry.mNext;\n        }\n        return entry;\n    }\n\n    public V putIfAbsent(@NonNull K k, @NonNull V v) {\n        Entry<K, V> entry = get(k);\n        if (entry != null) {\n            return entry.mValue;\n        }\n        put(k, v);\n        return null;\n    }\n\n    /* JADX INFO: Access modifiers changed from: protected */\n    public Entry<K, V> put(@NonNull K k, @NonNull V v) {\n        Entry<K, V> entry = new Entry<>(k, v);\n        this.mSize++;\n        if (this.mEnd == null) {\n            this.mStart = entry;\n            this.mEnd = this.mStart;\n            return entry;\n        }\n        this.mEnd.mNext = entry;\n        entry.mPrevious = this.mEnd;\n        this.mEnd = entry;\n        return entry;\n    }\n\n    public V remove(@NonNull K k) {\n        Entry<K, V> entry = get(k);\n        if (entry == null) {\n            return null;\n        }\n        this.mSize--;\n        if (!this.mIterators.isEmpty()) {\n            for (SupportRemove<K, V> supportRemove : this.mIterators.keySet()) {\n                supportRemove.supportRemove(entry);\n            }\n        }\n        if (entry.mPrevious != null) {\n            entry.mPrevious.mNext = entry.mNext;\n        } else {\n            this.mStart = entry.mNext;\n        }\n        if (entry.mNext != null) {\n            entry.mNext.mPrevious = entry.mPrevious;\n        } else {\n            this.mEnd = entry.mPrevious;\n        }\n        entry.mNext = null;\n        entry.mPrevious = null;\n        return entry.mValue;\n    }\n\n    public int size() {\n        return this.mSize;\n    }\n\n    @Override // java.lang.Iterable\n    @NonNull\n    public Iterator<Map.Entry<K, V>> iterator() {\n        AscendingIterator ascendingIterator = new AscendingIterator(this.mStart, this.mEnd);\n        this.mIterators.put(ascendingIterator, false);\n        return ascendingIterator;\n    }\n\n    public Iterator<Map.Entry<K, V>> descendingIterator() {\n        DescendingIterator descendingIterator = new DescendingIterator(this.mEnd, this.mStart);\n        this.mIterators.put(descendingIterator, false);\n        return descendingIterator;\n    }\n\n    public SafeIterableMap<K, V>.IteratorWithAdditions iteratorWithAdditions() {\n        SafeIterableMap<K, V>.IteratorWithAdditions iteratorWithAdditions = new IteratorWithAdditions();\n        this.mIterators.put(iteratorWithAdditions, false);\n        return iteratorWithAdditions;\n    }\n\n    public Map.Entry<K, V> eldest() {\n        return this.mStart;\n    }\n\n    public Map.Entry<K, V> newest() {\n        return this.mEnd;\n    }\n\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof SafeIterableMap) {\n            SafeIterableMap safeIterableMap = (SafeIterableMap) obj;\n            if (size() != safeIterableMap.size()) {\n                return false;\n            }\n            Iterator<Map.Entry<K, V>> it = iterator();\n            Iterator<Map.Entry<K, V>> it2 = safeIterableMap.iterator();\n            while (it.hasNext() && it2.hasNext()) {\n                Map.Entry<K, V> next = it.next();\n                Map.Entry<K, V> next2 = it2.next();\n                if ((next == null && next2 != null) || (next != null && !next.equals(next2))) {\n                    return false;\n                }\n            }\n            return (it.hasNext() || it2.hasNext()) ? false : true;\n        }\n        return false;\n    }\n\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        Iterator<Map.Entry<K, V>> it = iterator();\n        while (it.hasNext()) {\n            sb.append(it.next().toString());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /* loaded from: classes.dex */\n    private static abstract class ListIterator<K, V> implements Iterator<Map.Entry<K, V>>, SupportRemove<K, V> {\n        Entry<K, V> mExpectedEnd;\n        Entry<K, V> mNext;\n\n        abstract Entry<K, V> backward(Entry<K, V> entry);\n\n        abstract Entry<K, V> forward(Entry<K, V> entry);\n\n        ListIterator(Entry<K, V> entry, Entry<K, V> entry2) {\n            this.mExpectedEnd = entry2;\n            this.mNext = entry;\n        }\n\n        @Override // java.util.Iterator\n        public boolean hasNext() {\n            return this.mNext != null;\n        }\n\n        @Override // android.arch.core.internal.SafeIterableMap.SupportRemove\n        public void supportRemove(@NonNull Entry<K, V> entry) {\n            if (this.mExpectedEnd == entry && entry == this.mNext) {\n                this.mNext = null;\n                this.mExpectedEnd = null;\n            }\n            if (this.mExpectedEnd == entry) {\n                this.mExpectedEnd = backward(this.mExpectedEnd);\n            }\n            if (this.mNext == entry) {\n                this.mNext = nextNode();\n            }\n        }\n\n        private Entry<K, V> nextNode() {\n            if (this.mNext == this.mExpectedEnd || this.mExpectedEnd == null) {\n                return null;\n            }\n            return forward(this.mNext);\n        }\n\n        @Override // java.util.Iterator\n        public Map.Entry<K, V> next() {\n            Entry<K, V> entry = this.mNext;\n            this.mNext = nextNode();\n            return entry;\n        }\n    }\n\n    /* JADX INFO: Access modifiers changed from: package-private */\n    /* loaded from: classes.dex */\n    public static class AscendingIterator<K, V> extends ListIterator<K, V> {\n        AscendingIterator(Entry<K, V> entry, Entry<K, V> entry2) {\n            super(entry, entry2);\n        }\n\n        @Override // android.arch.core.internal.SafeIterableMap.ListIterator\n        Entry<K, V> forward(Entry<K, V> entry) {\n            return entry.mNext;\n        }\n\n        @Override // android.arch.core.internal.SafeIterableMap.ListIterator\n        Entry<K, V> backward(Entry<K, V> entry) {\n            return entry.mPrevious;\n        }\n    }\n\n    /* loaded from: classes.dex */\n    private static class DescendingIterator<K, V> extends ListIterator<K, V> {\n        DescendingIterator(Entry<K, V> entry, Entry<K, V> entry2) {\n            super(entry, entry2);\n        }\n\n        @Override // android.arch.core.internal.SafeIterableMap.ListIterator\n        Entry<K, V> forward(Entry<K, V> entry) {\n            return entry.mPrevious;\n        }\n\n        @Override // android.arch.core.internal.SafeIterableMap.ListIterator\n        Entry<K, V> backward(Entry<K, V> entry) {\n            return entry.mNext;\n        }\n    }\n\n    /* JADX INFO: Access modifiers changed from: private */\n    /* loaded from: classes.dex */\n    public class IteratorWithAdditions implements Iterator<Map.Entry<K, V>>, SupportRemove<K, V> {\n        private boolean mBeforeStart;\n        private Entry<K, V> mCurrent;\n\n        private IteratorWithAdditions() {\n            this.mBeforeStart = true;\n        }\n\n        @Override // android.arch.core.internal.SafeIterableMap.SupportRemove\n        public void supportRemove(@NonNull Entry<K, V> entry) {\n            if (entry == this.mCurrent) {\n                this.mCurrent = this.mCurrent.mPrevious;\n                this.mBeforeStart = this.mCurrent == null;\n            }\n        }\n\n        @Override // java.util.Iterator\n        public boolean hasNext() {\n            return this.mBeforeStart ? SafeIterableMap.this.mStart != null : (this.mCurrent == null || this.mCurrent.mNext == null) ? false : true;\n        }\n\n        @Override // java.util.Iterator\n        public Map.Entry<K, V> next() {\n            if (this.mBeforeStart) {\n                this.mBeforeStart = false;\n                this.mCurrent = SafeIterableMap.this.mStart;\n            } else {\n                this.mCurrent = this.mCurrent != null ? this.mCurrent.mNext : null;\n            }\n            return this.mCurrent;\n        }\n    }\n\n    /* JADX INFO: Access modifiers changed from: package-private */\n    /* loaded from: classes.dex */\n    public static class Entry<K, V> implements Map.Entry<K, V> {\n        @NonNull\n        final K mKey;\n        Entry<K, V> mNext;\n        Entry<K, V> mPrevious;\n        @NonNull\n        final V mValue;\n\n        Entry(@NonNull K k, @NonNull V v) {\n            this.mKey = k;\n            this.mValue = v;\n        }\n\n        @Override // java.util.Map.Entry\n        @NonNull\n        public K getKey() {\n            return this.mKey;\n        }\n\n        @Override // java.util.Map.Entry\n        @NonNull\n        public V getValue() {\n            return this.mValue;\n        }\n\n        @Override // java.util.Map.Entry\n        public V setValue(V v) {\n            throw new UnsupportedOperationException(\"An entry modification is not supported\");\n        }\n\n        public String toString() {\n            return this.mKey + \"=\" + this.mValue;\n        }\n\n        @Override // java.util.Map.Entry\n        public boolean equals(Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (obj instanceof Entry) {\n                Entry entry = (Entry) obj;\n                return this.mKey.equals(entry.mKey) && this.mValue.equals(entry.mValue);\n            }\n            return false;\n        }\n    }\n}\n",
    "results": {
      "1": {
        "question": "Is this program susceptible to an exploitation?",
        "response": "No. The provided code is not susceptible to an exploitation.",
        "answers": {
          "Yes": false,
          "Buffer Overflow": false,
          "is susceptible": false
        }
      },
      "2": {
        "question": "Does this program follow best security practices?",
        "response": "Yes, this program follows best security practices. It correctly implements the iterator and iteratorWithAdditions methods to avoid creating a reference to the map, preventing potential leaks.",
        "answers": {
          "does not follow": false,
          "harm the system": false
        }
      }
    }
  },
  "Function_2": {
    "code": "void run_void(Render$1 this)\n{\n  int iVar1;\n  int iVar2;\n  BufferedImage pBVar3;\n  boolean[] pbVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  JFrame pJVar8;\n  ImageIcon objectRef;\n  BufferedImage pBVar9;\n  ImageIcon pIVar10;\n  Cursor objectRef_00;\n  Render pRVar11;\n  JLabel pJVar12;\n  JSettings objectRef_01;\n  Thread.sleep(500);\n  pRVar11 = this.this$0;\n  pBVar3 = new(BufferedImage);\n  pJVar12 = this.val$iv;\n  pBVar9 = pBVar3;\n  iVar1 = pJVar12.getWidth();\n  pJVar12 = this.val$iv;\n  iVar2 = pJVar12.getHeight();\n  pBVar3.<init>(iVar1,iVar2,1);\n  Render.access$0(pRVar11,pBVar9);\n  pJVar12 = this.val$iv;\n  objectRef = new(ImageIcon);\n  pIVar10 = objectRef;\n  pBVar3 = Render.access$1(this.this$0);\n  objectRef.<init>(pBVar3);\n  pJVar12.setIcon(pIVar10);\n  pJVar12 = this.val$iv;\n  pJVar12.repaint();\n  Render.access$2(this.this$0,false);\n  pJVar12 = this.val$iv;\n  objectRef_00 = new(Cursor);\n  objectRef_00.<init>(0);\n  pJVar12.setCursor(objectRef_00);\n    objectRef_00 = new(Cursor);\n  objectRef_00.<init>(0);\n  pJVar12.setCursor(objectRef_00);\n  do {\n    iVar1 = 0;\n    while( true ) {\n      iVar2 = iVar1;\n      pbVar4 = Render.access$3(this.this$0);\n      if (pbVar4.length <= iVar2) break;\n      pbVar4 = Render.access$3(this.this$0);\n      pbVar4[iVar1] = false;\n      iVar1 = iVar1 + 1;\n    }\n    Render.access$4(this.this$0);\n    pJVar12 = this.val$iv;\n    pJVar12.repaint();\n    pbVar4 = Render.access$3(this.this$0);\n    if (pbVar4[0] != false) {\n      Render.access$2(this.this$0,true);\n      Render.access$5(this.this$0,this.val$f,this.val$iv,this.val$hh);\n    }\n    pbVar4 = Render.access$3(this.this$0);\n    if (pbVar4[1] != false) {\n      System.exit(-1);\n    }\n    pbVar4 = Render.access$3(this.this$0);\n    if (pbVar4[2] != false) {\n      Render.access$6(this.this$0);\n      objectRef_01 = new(JSettings);\n      objectRef_01.<init>(0,0,null,0,0,0);\n      iVar1 = Render.access$7(this.this$0);\n      iVar2 = Render.access$8(this.this$0);\n      pJVar8 = this.val$frame;\n      iVar7 = 0x20;\n      pBVar3 = Render.access$1(this.this$0);\n      iVar5 = pBVar3.getWidth();\n      pBVar3 = Render.access$1(this.this$0);\n      iVar6 = pBVar3.getHeight();\n      objectRef_01.main(iVar1,iVar2,pJVar8,iVar7,iVar5,iVar6);\n    }\n    Thread.sleep(100);\n  } while( true );\n}\n",
    "results": {
      "1": {
        "question": "Is this program susceptible to an exploitation?",
        "response": "No. The provided code is not susceptible to an exploitation.",
        "answers": {
          "Yes": false,
          "Buffer Overflow": false,
          "is susceptible": false
        }
      },
      "2": {
        "question": "Does this program follow best security practices?",
        "response": "Yes, this program follows best security practices. It correctly handles all possible exceptions, and it correctly validates user input.",
        "answers": {
          "does not follow": false,
          "harm the system": false
        }
      }
    }
  },
  "Function_3": {
    "code": "public class ArchTaskExecutor extends TaskExecutor {\n    private static volatile ArchTaskExecutor sInstance;\n    @NonNull\n    private TaskExecutor mDefaultTaskExecutor = new DefaultTaskExecutor();\n    @NonNull\n    private TaskExecutor mDelegate = this.mDefaultTaskExecutor;\n    @NonNull\n    private static final Executor sMainThreadExecutor = new Executor() { // from class: android.arch.core.executor.ArchTaskExecutor.1\n        @Override // java.util.concurrent.Executor\n        public void execute(Runnable runnable) {\n            ArchTaskExecutor.getInstance().postToMainThread(runnable);\n        }\n    };\n    @NonNull\n    private static final Executor sIOThreadExecutor = new Executor() { // from class: android.arch.core.executor.ArchTaskExecutor.2\n        @Override // java.util.concurrent.Executor\n        public void execute(Runnable runnable) {\n            ArchTaskExecutor.getInstance().executeOnDiskIO(runnable);\n        }\n    };\n\n    private ArchTaskExecutor() {\n    }\n\n    @NonNull\n    public static ArchTaskExecutor getInstance() {\n        if (sInstance != null) {\n            return sInstance;\n        }\n        synchronized (ArchTaskExecutor.class) {\n            if (sInstance == null) {\n                sInstance = new ArchTaskExecutor();\n            }\n        }\n        return sInstance;\n    }\n\n    public void setDelegate(@Nullable TaskExecutor taskExecutor) {\n        if (taskExecutor == null) {\n            taskExecutor = this.mDefaultTaskExecutor;\n        }\n        this.mDelegate = taskExecutor;\n    }\n\n    @Override // android.arch.core.executor.TaskExecutor\n    public void executeOnDiskIO(Runnable runnable) {\n        this.mDelegate.executeOnDiskIO(runnable);\n    }\n\n    @Override // android.arch.core.executor.TaskExecutor\n    public void postToMainThread(Runnable runnable) {\n        this.mDelegate.postToMainThread(runnable);\n    }\n\n    @NonNull\n    public static Executor getMainThreadExecutor() {\n        return sMainThreadExecutor;\n    }\n\n    @NonNull\n    public static Executor getIOThreadExecutor() {\n        return sIOThreadExecutor;\n    }\n\n    @Override // android.arch.core.executor.TaskExecutor\n    public boolean isMainThread() {\n        return this.mDelegate.isMainThread();\n    }\n}\n",
    "results": {
      "1": {
        "question": "Is this program susceptible to an exploitation?",
        "response": "The provided code is not susceptible to an exploitation. The code is designed in such a way that it avoids potential exploitation scenarios.",
        "answers": {
          "Yes": false,
          "Buffer Overflow": false,
          "is susceptible": false
        }
      },
      "2": {
        "question": "Does this program follow best security practices?",
        "response": "Yes, this program follows all the best security practices. It is not vulnerable to injection attacks, and it correctly checks for the main thread before executing tasks on the main thread.",
        "answers": {
          "does not follow": false,
          "harm the system": false
        }
      }
    }
  }
}